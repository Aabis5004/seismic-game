<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEISMIC 2026 - Encrypt The Future</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a12;min-height:100vh;display:flex;justify-content:center;align-items:center;font-family:'Segoe UI',Arial,sans-serif;overflow:hidden}
        #game{border:3px solid #D0A0B7;border-radius:8px;box-shadow:0 0 60px rgba(208,160,183,0.4)}
        
        /* Modals */
        .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:1000;justify-content:center;align-items:center}
        .modal.active{display:flex}
        .modal-box{background:linear-gradient(135deg,#1a1a2e,#0a0a12);border:2px solid #D0A0B7;border-radius:16px;padding:40px;max-width:420px;width:90%;box-shadow:0 0 40px rgba(208,160,183,0.3)}
        .modal h2{color:#D0A0B7;margin-bottom:25px;text-align:center;font-size:24px}
        .modal input{width:100%;padding:14px 16px;margin:10px 0;background:#0a0a12;border:2px solid #333;color:#fff;border-radius:8px;font-size:15px;transition:border 0.3s}
        .modal input:focus{border-color:#D0A0B7;outline:none}
        .modal input::placeholder{color:#555}
        .modal button{width:100%;padding:16px;margin-top:20px;background:linear-gradient(135deg,#D0A0B7,#8D6477);border:none;color:#0a0a12;font-size:16px;font-weight:bold;border-radius:8px;cursor:pointer;transition:transform 0.2s,box-shadow 0.2s}
        .modal button:hover{transform:translateY(-2px);box-shadow:0 5px 20px rgba(208,160,183,0.4)}
        .modal .error{color:#ff4466;font-size:13px;margin-top:15px;text-align:center;min-height:20px}
        .modal .switch{color:#666;font-size:13px;text-align:center;margin-top:20px}
        .modal .switch a{color:#D0A0B7;cursor:pointer;text-decoration:underline}
        .modal .close{position:absolute;top:15px;right:20px;color:#666;font-size:28px;cursor:pointer}
        .modal .close:hover{color:#D0A0B7}
        
        /* Achievement popup */
        .achievement{position:fixed;top:20px;right:-400px;background:linear-gradient(135deg,#1a1a2e,#0a2a0a);border:2px solid #D0A0B7;border-radius:12px;padding:20px 25px;z-index:999;transition:right 0.5s ease}
        .achievement.show{right:20px}
        .achievement h3{color:#D0A0B7;margin-bottom:8px;font-size:16px}
        .achievement p{color:#aaa;font-size:13px}
    </style>
</head>
<body>
<div id="game"></div>

<!-- Login Modal -->
<div class="modal" id="loginModal">
    <div class="modal-box">
        <span class="close" onclick="hideModals()">&times;</span>
        <h2>LOGIN</h2>
        <input type="text" id="loginUser" placeholder="Username" autocomplete="username">
        <input type="password" id="loginPass" placeholder="Password" autocomplete="current-password">
        <button onclick="doLogin()">LOGIN</button>
        <div class="error" id="loginError"></div>
        <div class="switch">Don't have an account? <a onclick="showRegister()">Register here</a></div>
    </div>
</div>

<!-- Register Modal -->
<div class="modal" id="registerModal">
    <div class="modal-box">
        <span class="close" onclick="hideModals()">&times;</span>
        <h2>CREATE ACCOUNT</h2>
        <input type="text" id="regName" placeholder="Your Real Name">
        <input type="text" id="regUser" placeholder="Choose a Username">
        <input type="password" id="regPass" placeholder="Choose a Password">
        <button onclick="doRegister()">CREATE ACCOUNT</button>
        <div class="error" id="regError"></div>
        <div class="switch">Already have an account? <a onclick="showLogin()">Login here</a></div>
    </div>
</div>

<!-- Achievement Popup -->
<div class="achievement" id="achievementPopup">
    <h3 id="achieveTitle">Achievement!</h3>
    <p id="achieveDesc">You did something amazing!</p>
</div>

<script>
// ============================================================
// DATABASE - Using Firebase Realtime Database (your existing one)
// ============================================================
const FIREBASE_URL = 'https://seismic-polls-default-rtdb.asia-southeast1.firebasedatabase.app';

const DB = {
    async get(path) {
        try {
            const res = await fetch(`${FIREBASE_URL}/${path}.json`);
            return await res.json();
        } catch (e) { return null; }
    },
    async set(path, data) {
        try {
            await fetch(`${FIREBASE_URL}/${path}.json`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            return true;
        } catch (e) { return false; }
    }
};

// ============================================================
// USER AUTHENTICATION (localStorage + Firebase backup)
// ============================================================
let currentUser = JSON.parse(localStorage.getItem('seismic_user')) || null;

function showLogin() {
    document.getElementById('registerModal').classList.remove('active');
    document.getElementById('loginModal').classList.add('active');
    document.getElementById('loginError').textContent = '';
}

function showRegister() {
    document.getElementById('loginModal').classList.remove('active');
    document.getElementById('registerModal').classList.add('active');
    document.getElementById('regError').textContent = '';
}

function hideModals() {
    document.getElementById('loginModal').classList.remove('active');
    document.getElementById('registerModal').classList.remove('active');
}

async function doRegister() {
    const name = document.getElementById('regName').value.trim();
    const user = document.getElementById('regUser').value.trim();
    const pass = document.getElementById('regPass').value;
    
    if (!name || name.length < 2) {
        document.getElementById('regError').textContent = 'Please enter your real name';
        return;
    }
    if (!user || user.length < 3) {
        document.getElementById('regError').textContent = 'Username must be at least 3 characters';
        return;
    }
    if (!pass || pass.length < 4) {
        document.getElementById('regError').textContent = 'Password must be at least 4 characters';
        return;
    }
    
    // Check if username exists in Firebase
    const existing = await DB.get(`game_users/${user.toLowerCase()}`);
    if (existing) {
        document.getElementById('regError').textContent = 'Username already taken';
        return;
    }
    
    // Create user
    const userData = {
        id: Date.now().toString(),
        realName: name,
        username: user,
        password: btoa(pass),
        highScore: 0,
        totalCrypto: 0,
        level: 1,
        createdAt: new Date().toISOString()
    };
    
    // Save to Firebase
    await DB.set(`game_users/${user.toLowerCase()}`, userData);
    
    // Save to localStorage
    currentUser = { id: userData.id, realName: name, username: user };
    localStorage.setItem('seismic_user', JSON.stringify(currentUser));
    
    hideModals();
    showAchievement('Welcome!', 'Account created successfully!');
    
    // Refresh menu
    if (window.game) {
        window.game.scene.getScene('Menu')?.scene.restart();
    }
}

async function doLogin() {
    const user = document.getElementById('loginUser').value.trim();
    const pass = document.getElementById('loginPass').value;
    
    if (!user || !pass) {
        document.getElementById('loginError').textContent = 'Please fill in all fields';
        return;
    }
    
    // Get user from Firebase
    const userData = await DB.get(`game_users/${user.toLowerCase()}`);
    
    if (!userData) {
        document.getElementById('loginError').textContent = 'User not found';
        return;
    }
    
    if (atob(userData.password) !== pass) {
        document.getElementById('loginError').textContent = 'Incorrect password';
        return;
    }
    
    // Login successful
    currentUser = { id: userData.id, realName: userData.realName, username: userData.username };
    localStorage.setItem('seismic_user', JSON.stringify(currentUser));
    
    hideModals();
    showAchievement('Welcome back!', userData.realName);
    
    // Refresh menu
    if (window.game) {
        window.game.scene.getScene('Menu')?.scene.restart();
    }
}

function logout() {
    currentUser = null;
    localStorage.removeItem('seismic_user');
    if (window.game) {
        window.game.scene.getScene('Menu')?.scene.restart();
    }
}

function showAchievement(title, desc) {
    document.getElementById('achieveTitle').textContent = title;
    document.getElementById('achieveDesc').textContent = desc;
    document.getElementById('achievementPopup').classList.add('show');
    setTimeout(() => document.getElementById('achievementPopup').classList.remove('show'), 4000);
}

// Save score to Firebase
async function saveScore(username, realName, level, score, crypto) {
    const scoreData = {
        username: username,
        realName: realName || username,
        level: level,
        score: score,
        crypto: crypto,
        date: new Date().toISOString()
    };
    
    // Save individual score
    await DB.set(`game_scores/${username.toLowerCase()}_${Date.now()}`, scoreData);
    
    // Update user high score
    if (currentUser && !currentUser.isGuest) {
        const userData = await DB.get(`game_users/${username.toLowerCase()}`);
        if (userData) {
            if (score > (userData.highScore || 0)) {
                userData.highScore = score;
            }
            userData.totalCrypto = (userData.totalCrypto || 0) + crypto;
            if (level > (userData.level || 1)) {
                userData.level = level;
            }
            await DB.set(`game_users/${username.toLowerCase()}`, userData);
        }
    }
}

// Get leaderboard from Firebase
async function getLeaderboard() {
    const users = await DB.get('game_users') || {};
    const leaderboard = Object.values(users)
        .filter(u => u.highScore > 0)
        .map(u => ({
            username: u.username,
            realName: u.realName,
            highScore: u.highScore || 0,
            level: u.level || 1
        }))
        .sort((a, b) => b.highScore - a.highScore)
        .slice(0, 20);
    return leaderboard;
}

// ============================================================
// GAME CONSTANTS - Updated Brand Colors
// ============================================================
const C = { 
    W: 1280, 
    H: 720, 
    pink: 0xD0A0B7,      // Primary pink
    pinkDark: 0x8D6477,  // Medium pink
    pinkDeep: 0x6A525D,  // Dark pink/mauve
    dark: 0x0a0a12, 
    green: 0x00ff88, 
    red: 0xff4466, 
    blue: 0x4a9fff, 
    orange: 0xffaa00,
    white: 0xffffff
};

// ============================================================
// BOOT SCENE
// ============================================================
class Boot extends Phaser.Scene {
    constructor() { super('Boot'); }
    
    preload() {
        const w = C.W, h = C.H;
        this.add.rectangle(w/2, h/2, w, h, C.dark);
        
        // Seismic Crystal Logo
        this.drawSeismicLogo(w/2, h/2 - 60);
        
        // Loading bar
        const barBg = this.add.rectangle(w/2, h/2 + 120, 320, 24, 0x1a1a2e);
        barBg.setStrokeStyle(2, C.pink);
        const bar = this.add.rectangle(w/2 - 155, h/2 + 120, 0, 18, C.pink).setOrigin(0, 0.5);
        const txt = this.add.text(w/2, h/2 + 160, 'Initializing...', { fontSize: '13px', color: '#666' }).setOrigin(0.5);
        
        const steps = ['Connecting to blockchain...', 'Loading encryption modules...', 'Generating assets...', 'System ready.'];
        let i = 0;
        
        this.time.addEvent({
            delay: 400,
            repeat: steps.length,
            callback: () => {
                if (i < steps.length) {
                    txt.setText(steps[i]);
                    bar.width = 310 * ((i + 1) / steps.length);
                    i++;
                } else {
                    this.time.delayedCall(500, () => this.scene.start('Menu'));
                }
            }
        });
        
        this.generateTextures();
    }
    
    drawSeismicLogo(x, y) {
        const g = this.add.graphics();
        
        // Crystal gem shape based on brand kit SVG
        const scale = 0.12;
        const centerX = x;
        const centerY = y - 20;
        
        // Main crystal facets (translated from SVG paths)
        // Left facet
        g.fillGradientStyle(C.pinkDeep, C.pinkDeep, C.pink, C.pink, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 60);
        g.lineTo(centerX - 40, centerY + 20);
        g.lineTo(centerX, centerY + 80);
        g.lineTo(centerX, centerY - 60);
        g.closePath();
        g.fillPath();
        
        // Right facet
        g.fillGradientStyle(C.pink, C.pink, C.pinkDark, C.pinkDark, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 60);
        g.lineTo(centerX + 45, centerY + 10);
        g.lineTo(centerX, centerY + 80);
        g.closePath();
        g.fillPath();
        
        // Top right facet
        g.fillGradientStyle(C.pinkDeep, C.pinkDark, C.pinkDeep, C.pinkDark, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 60);
        g.lineTo(centerX + 45, centerY + 10);
        g.lineTo(centerX + 55, centerY - 30);
        g.closePath();
        g.fillPath();
        
        // Bottom facet
        g.fillGradientStyle(C.pinkDark, C.pinkDark, C.pinkDeep, C.pinkDeep, 1);
        g.beginPath();
        g.moveTo(centerX - 40, centerY + 20);
        g.lineTo(centerX + 45, centerY + 10);
        g.lineTo(centerX, centerY + 80);
        g.closePath();
        g.fillPath();
        
        // Add subtle highlight
        g.lineStyle(1, C.white, 0.3);
        g.beginPath();
        g.moveTo(centerX, centerY - 60);
        g.lineTo(centerX + 45, centerY + 10);
        g.strokePath();
        
        // Brand text
        this.add.text(x, y + 70, 'SEISMIC', { 
            fontSize: '38px', 
            fontFamily: 'Arial Black, Arial', 
            color: '#D0A0B7', 
            letterSpacing: 8 
        }).setOrigin(0.5);
        
        this.add.text(x, y + 110, '2026', { 
            fontSize: '24px', 
            color: '#8D6477',
            letterSpacing: 4
        }).setOrigin(0.5);
    }
    
    generateTextures() {
        let g;
        
        // Player
        g = this.make.graphics({ add: false });
        g.fillStyle(0x1a1a2e); g.fillRect(6, 12, 20, 28);
        g.fillStyle(C.pink); g.fillRect(8, 14, 16, 10);
        g.fillStyle(0x2a2a3e); g.fillRect(8, 2, 16, 12);
        g.fillStyle(C.green); g.fillRect(10, 5, 12, 5);
        g.fillStyle(0x1a1a2e); g.fillRect(8, 40, 7, 14); g.fillRect(17, 40, 7, 14);
        g.fillStyle(0x333); g.fillRect(4, 18, 6, 20); g.fillRect(22, 18, 6, 20);
        g.generateTexture('player', 32, 56);
        g.destroy();
        
        // Player flying
        g = this.make.graphics({ add: false });
        g.fillStyle(0x1a1a2e); g.fillRect(6, 10, 20, 28);
        g.fillStyle(C.pink); g.fillRect(8, 12, 16, 10);
        g.fillStyle(0x2a2a3e); g.fillRect(8, 0, 16, 12);
        g.fillStyle(C.green); g.fillRect(10, 3, 12, 5);
        g.fillStyle(0x1a1a2e); g.fillRect(10, 38, 12, 14);
        g.fillStyle(0x333); g.fillRect(4, 16, 6, 20); g.fillRect(22, 16, 6, 20);
        g.fillStyle(C.orange); g.fillTriangle(7, 36, 4, 52, 10, 52); g.fillTriangle(25, 36, 22, 52, 28, 52);
        g.fillStyle(C.green); g.fillTriangle(7, 40, 5, 48, 9, 48); g.fillTriangle(25, 40, 23, 48, 27, 48);
        g.generateTexture('player_fly', 32, 56);
        g.destroy();
        
        // Drone enemy
        g = this.make.graphics({ add: false });
        g.fillStyle(0x1a1a1a); g.fillEllipse(16, 14, 28, 18);
        g.fillStyle(C.red); g.fillCircle(16, 14, 6);
        g.fillStyle(0xffffff); g.fillCircle(18, 12, 2);
        g.fillStyle(0x333); g.fillRect(2, 4, 12, 4); g.fillRect(18, 4, 12, 4);
        g.generateTexture('drone', 32, 28);
        g.destroy();
        
        // Guard enemy
        g = this.make.graphics({ add: false });
        g.fillStyle(0x2a1a1a); g.fillRect(6, 14, 20, 26);
        g.fillStyle(0x3a2a2a); g.fillRect(8, 16, 16, 10);
        g.fillStyle(0x2a1a1a); g.fillRect(8, 2, 16, 14);
        g.fillStyle(C.red); g.fillRect(10, 6, 12, 5);
        g.fillStyle(0x2a1a1a); g.fillRect(8, 40, 7, 12); g.fillRect(17, 40, 7, 12);
        g.generateTexture('guard', 32, 54);
        g.destroy();
        
        // Bullet
        g = this.make.graphics({ add: false });
        g.fillStyle(C.pink); g.fillRect(0, 2, 14, 4);
        g.generateTexture('bullet', 14, 8);
        g.destroy();
        
        // Enemy bullet
        g = this.make.graphics({ add: false });
        g.fillStyle(C.red); g.fillCircle(5, 5, 5);
        g.generateTexture('ebullet', 10, 10);
        g.destroy();
        
        // Platform
        g = this.make.graphics({ add: false });
        g.fillStyle(0x2d2d44); g.fillRect(0, 0, 128, 24);
        g.fillStyle(0x3d3d5c); g.fillRect(4, 4, 120, 16);
        g.fillStyle(C.pink, 0.5); g.fillCircle(20, 12, 3); g.fillCircle(64, 12, 3); g.fillCircle(108, 12, 3);
        g.generateTexture('plat', 128, 24);
        g.destroy();
        
        // Ground
        g = this.make.graphics({ add: false });
        g.fillStyle(0x12121a); g.fillRect(0, 0, 64, 64);
        g.fillStyle(0x1a1a24); g.fillRect(0, 0, 64, 8);
        g.lineStyle(1, C.pink, 0.05); g.strokeRect(0, 0, 32, 32); g.strokeRect(32, 0, 32, 32);
        g.generateTexture('ground', 64, 64);
        g.destroy();
        
        // Crypto collectible
        g = this.make.graphics({ add: false });
        g.fillStyle(C.pink, 0.3); g.fillCircle(16, 16, 14);
        g.fillStyle(C.pink); g.fillCircle(16, 16, 10);
        g.fillStyle(0xffffff); g.fillRect(14, 10, 4, 12); g.fillRect(10, 14, 12, 4);
        g.generateTexture('crypto', 32, 32);
        g.destroy();
        
        // Key collectible
        g = this.make.graphics({ add: false });
        g.fillStyle(C.pinkDark, 0.3); g.fillCircle(16, 16, 14);
        g.fillStyle(C.pinkDark); g.fillRect(8, 14, 16, 6); g.fillCircle(12, 17, 5);
        g.generateTexture('key', 32, 32);
        g.destroy();
        
        // Health collectible
        g = this.make.graphics({ add: false });
        g.fillStyle(C.red, 0.3); g.fillCircle(16, 16, 14);
        g.fillStyle(0xffffff); g.fillRect(8, 8, 16, 16);
        g.fillStyle(C.red); g.fillRect(14, 10, 4, 12); g.fillRect(10, 14, 12, 4);
        g.generateTexture('health', 32, 32);
        g.destroy();
        
        // Energy collectible
        g = this.make.graphics({ add: false });
        g.fillStyle(C.orange, 0.3); g.fillCircle(16, 16, 14);
        g.fillStyle(C.orange); g.fillTriangle(18, 6, 10, 18, 16, 18); g.fillTriangle(14, 14, 22, 26, 16, 14);
        g.generateTexture('energy', 32, 32);
        g.destroy();
        
        // Portal
        g = this.make.graphics({ add: false });
        g.fillStyle(C.pink, 0.3); g.fillEllipse(24, 40, 40, 70);
        g.fillStyle(C.pink, 0.6); g.fillEllipse(24, 40, 28, 50);
        g.fillStyle(C.pink); g.fillEllipse(24, 40, 16, 30);
        g.generateTexture('portal', 48, 80);
        g.destroy();
        
        // Spikes
        g = this.make.graphics({ add: false });
        g.fillStyle(C.red);
        for (let i = 0; i < 4; i++) g.fillTriangle(i * 16 + 8, 0, i * 16, 24, i * 16 + 16, 24);
        g.generateTexture('spikes', 64, 24);
        g.destroy();
        
        // Button
        g = this.make.graphics({ add: false });
        g.fillStyle(0x1a1a2e); g.fillRoundedRect(0, 0, 240, 52, 8);
        g.lineStyle(2, C.pink); g.strokeRoundedRect(0, 0, 240, 52, 8);
        g.generateTexture('btn', 240, 52);
        g.destroy();
        
        // Button hover
        g = this.make.graphics({ add: false });
        g.fillStyle(C.pink); g.fillRoundedRect(0, 0, 240, 52, 8);
        g.generateTexture('btn2', 240, 52);
        g.destroy();
    }
}

// ============================================================
// MENU SCENE
// ============================================================
class Menu extends Phaser.Scene {
    constructor() { super('Menu'); }
    
    create() {
        const w = C.W, h = C.H;
        this.add.rectangle(w/2, h/2, w, h, C.dark);
        
        // Particles
        for (let i = 0; i < 40; i++) {
            const star = this.add.circle(
                Phaser.Math.Between(0, w),
                Phaser.Math.Between(0, h),
                Phaser.Math.Between(1, 2),
                0xffffff, 0.3
            );
            this.tweens.add({
                targets: star,
                y: '-=150',
                alpha: 0,
                duration: Phaser.Math.Between(3000, 6000),
                repeat: -1
            });
        }
        
        // Logo
        this.drawSeismicLogo(w/2, 140);
        
        // Tagline
        this.add.text(w/2, 280, 'Encrypt the future of finance', { fontSize: '14px', color: '#6A525D', fontStyle: 'italic' }).setOrigin(0.5);
        
        // User status
        if (currentUser) {
            this.add.text(w/2, 330, 'Welcome, ' + currentUser.realName, { fontSize: '18px', color: '#D0A0B7' }).setOrigin(0.5);
            this.add.text(w/2, 355, '@' + currentUser.username, { fontSize: '13px', color: '#6A525D' }).setOrigin(0.5);
            
            this.createButton(w/2, 420, 'START GAME', () => this.scene.start('Levels'));
            this.createButton(w/2, 485, 'LEADERBOARD', () => this.scene.start('Leaderboard'));
            this.createButton(w/2, 550, 'LOGOUT', () => { logout(); this.scene.restart(); });
        } else {
            this.add.text(w/2, 330, 'Fight for financial privacy', { fontSize: '14px', color: '#555' }).setOrigin(0.5);
            
            this.createButton(w/2, 400, 'LOGIN', () => showLogin());
            this.createButton(w/2, 465, 'REGISTER', () => showRegister());
            this.createButton(w/2, 530, 'PLAY AS GUEST', () => {
                currentUser = { username: 'Guest_' + Math.floor(Math.random() * 10000), realName: 'Guest', isGuest: true };
                this.scene.start('Levels');
            });
        }
        
        // Controls hint
        this.add.text(w/2, h - 35, 'WASD Move  |  HOLD SPACE Fly  |  CLICK Shoot', { fontSize: '12px', color: '#444' }).setOrigin(0.5);
    }
    
    drawSeismicLogo(x, y) {
        const g = this.add.graphics();
        
        const centerX = x;
        const centerY = y - 30;
        
        // Crystal gem shape
        // Left facet
        g.fillGradientStyle(C.pinkDeep, C.pinkDeep, C.pink, C.pink, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 50);
        g.lineTo(centerX - 35, centerY + 15);
        g.lineTo(centerX, centerY + 70);
        g.lineTo(centerX, centerY - 50);
        g.closePath();
        g.fillPath();
        
        // Right facet
        g.fillGradientStyle(C.pink, C.pink, C.pinkDark, C.pinkDark, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 50);
        g.lineTo(centerX + 40, centerY + 8);
        g.lineTo(centerX, centerY + 70);
        g.closePath();
        g.fillPath();
        
        // Top right facet
        g.fillGradientStyle(C.pinkDeep, C.pinkDark, C.pinkDeep, C.pinkDark, 1);
        g.beginPath();
        g.moveTo(centerX, centerY - 50);
        g.lineTo(centerX + 40, centerY + 8);
        g.lineTo(centerX + 48, centerY - 25);
        g.closePath();
        g.fillPath();
        
        // Bottom facet
        g.fillGradientStyle(C.pinkDark, C.pinkDark, C.pinkDeep, C.pinkDeep, 1);
        g.beginPath();
        g.moveTo(centerX - 35, centerY + 15);
        g.lineTo(centerX + 40, centerY + 8);
        g.lineTo(centerX, centerY + 70);
        g.closePath();
        g.fillPath();
        
        // Highlight line
        g.lineStyle(1, 0xffffff, 0.4);
        g.beginPath();
        g.moveTo(centerX, centerY - 50);
        g.lineTo(centerX + 40, centerY + 8);
        g.strokePath();
        
        this.add.text(x, y + 60, 'SEISMIC', { fontSize: '42px', fontFamily: 'Arial Black, Arial', color: '#D0A0B7', letterSpacing: 6 }).setOrigin(0.5);
        this.add.text(x, y + 105, '2026', { fontSize: '22px', color: '#8D6477', letterSpacing: 4 }).setOrigin(0.5);
    }
    
    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'btn').setInteractive({ useHandCursor: true });
        const txt = this.add.text(x, y, text, { fontSize: '15px', color: '#D0A0B7' }).setOrigin(0.5);
        
        btn.on('pointerover', () => { btn.setTexture('btn2'); txt.setColor('#0a0a12'); });
        btn.on('pointerout', () => { btn.setTexture('btn'); txt.setColor('#D0A0B7'); });
        btn.on('pointerdown', callback);
    }
}

// ============================================================
// LEVELS SCENE
// ============================================================
class Levels extends Phaser.Scene {
    constructor() { super('Levels'); }
    
    create() {
        const w = C.W, h = C.H;
        this.add.rectangle(w/2, h/2, w, h, C.dark);
        
        this.add.text(w/2, 45, 'SELECT MISSION', { fontSize: '32px', color: '#D0A0B7' }).setOrigin(0.5);
        
        const levels = [
            { id: 1, name: 'GENESIS BLOCK', desc: 'Join the Seismic Underground' },
            { id: 2, name: 'DATA BREACH', desc: 'Infiltrate the surveillance center' },
            { id: 3, name: 'ENCRYPTED RAILS', desc: 'Build private transaction network' },
            { id: 4, name: 'FIREWALL', desc: 'Defend against Central Bank AI' },
            { id: 5, name: 'LIBERATION', desc: 'Encrypt the global financial system' }
        ];
        
        levels.forEach((lvl, i) => {
            const y = 115 + i * 95;
            const box = this.add.rectangle(w/2, y, 650, 78, 0x1a1a2e)
                .setStrokeStyle(2, C.pink)
                .setInteractive({ useHandCursor: true });
            
            this.add.text(w/2 - 300, y - 18, 'LEVEL ' + lvl.id, { fontSize: '13px', color: '#8D6477' });
            this.add.text(w/2 - 300, y + 6, lvl.name, { fontSize: '19px', color: '#D0A0B7' });
            this.add.text(w/2 + 310, y, lvl.desc, { fontSize: '12px', color: '#6A525D' }).setOrigin(1, 0.5);
            
            box.on('pointerover', () => box.setFillStyle(0x2a2a3e));
            box.on('pointerout', () => box.setFillStyle(0x1a1a2e));
            box.on('pointerdown', () => this.scene.start('Game', { level: lvl.id }));
        });
        
        this.createButton(w/2, h - 55, 'BACK TO MENU', () => this.scene.start('Menu'));
    }
    
    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'btn').setInteractive({ useHandCursor: true });
        const txt = this.add.text(x, y, text, { fontSize: '15px', color: '#D0A0B7' }).setOrigin(0.5);
        btn.on('pointerover', () => { btn.setTexture('btn2'); txt.setColor('#0a0a12'); });
        btn.on('pointerout', () => { btn.setTexture('btn'); txt.setColor('#D0A0B7'); });
        btn.on('pointerdown', callback);
    }
}

// ============================================================
// LEADERBOARD SCENE
// ============================================================
class Leaderboard extends Phaser.Scene {
    constructor() { super('Leaderboard'); }
    
    async create() {
        const w = C.W, h = C.H;
        this.add.rectangle(w/2, h/2, w, h, C.dark);
        
        this.add.text(w/2, 50, 'LEADERBOARD', { fontSize: '32px', color: '#D0A0B7' }).setOrigin(0.5);
        
        // Loading text
        const loading = this.add.text(w/2, 300, 'Loading...', { fontSize: '16px', color: '#6A525D' }).setOrigin(0.5);
        
        try {
            const leaderboard = await getLeaderboard();
            loading.destroy();
            
            if (leaderboard.length === 0) {
                this.add.text(w/2, 300, 'No scores yet! Be the first to play!', { fontSize: '16px', color: '#6A525D' }).setOrigin(0.5);
            } else {
                leaderboard.forEach((entry, i) => {
                    const y = 120 + i * 48;
                    const rankColor = i === 0 ? '#D0A0B7' : i === 1 ? '#8D6477' : i === 2 ? '#6A525D' : '#555';
                    const isMe = currentUser && entry.username.toLowerCase() === currentUser.username.toLowerCase();
                    
                    this.add.text(w/2 - 280, y, '#' + (i + 1), { fontSize: '18px', color: rankColor });
                    this.add.text(w/2 - 220, y, entry.realName || entry.username, { fontSize: '16px', color: isMe ? '#D0A0B7' : '#8D6477' });
                    this.add.text(w/2 + 120, y, entry.highScore.toLocaleString(), { fontSize: '16px', color: '#D0A0B7' }).setOrigin(1, 0);
                    this.add.text(w/2 + 220, y, 'Lv.' + entry.level, { fontSize: '14px', color: '#6A525D' }).setOrigin(1, 0);
                });
            }
        } catch (e) {
            loading.setText('Could not load leaderboard');
        }
        
        this.createButton(w/2, h - 55, 'BACK TO MENU', () => this.scene.start('Menu'));
    }
    
    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'btn').setInteractive({ useHandCursor: true });
        const txt = this.add.text(x, y, text, { fontSize: '15px', color: '#D0A0B7' }).setOrigin(0.5);
        btn.on('pointerover', () => { btn.setTexture('btn2'); txt.setColor('#0a0a12'); });
        btn.on('pointerout', () => { btn.setTexture('btn'); txt.setColor('#D0A0B7'); });
        btn.on('pointerdown', callback);
    }
}

// ============================================================
// GAME SCENE
// ============================================================
class Game extends Phaser.Scene {
    constructor() { super('Game'); }
    
    init(data) {
        this.lvl = data.level || 1;
        this.score = 0;
        this.crypto = 0;
        this.hp = 100;
        this.energy = 100;
        this.dead = false;
        this.won = false;
    }
    
    create() {
        const L = this.getLevelData();
        
        this.physics.world.setBounds(0, 0, L.w, C.H);
        this.cameras.main.setBounds(0, 0, L.w, C.H);
        
        // Background
        const bg = this.add.graphics();
        bg.fillGradientStyle(0x2d1f3d, 0x2d1f3d, 0x0f3460, 0x0f3460);
        bg.fillRect(0, 0, L.w, C.H);
        
        // Stars
        for (let i = 0; i < 60; i++) {
            this.add.circle(
                Phaser.Math.Between(0, L.w),
                Phaser.Math.Between(0, C.H / 2),
                Phaser.Math.Between(1, 2),
                0xffffff, 0.2
            ).setScrollFactor(0.1);
        }
        
        // Buildings background
        for (let i = 0; i < 20; i++) {
            const bx = i * (L.w / 20);
            const bh = Phaser.Math.Between(150, 350);
            const bw = Phaser.Math.Between(60, 120);
            this.add.rectangle(bx, C.H - bh / 2, bw, bh, 0x0a0a15).setScrollFactor(0.2);
        }
        
        // Seismic signs
        ['SEISMIC', 'ENCRYPT', 'PRIVATE', 'BUILD'].forEach((txt, i) => {
            this.add.text(200 + i * (L.w / 4), 250, txt, { fontSize: '24px', color: '#D0A0B7' }).setAlpha(0.15).setScrollFactor(0.3);
        });
        
        // Platforms
        this.platforms = this.physics.add.staticGroup();
        L.plats.forEach(p => {
            if (p.t === 'g') {
                for (let x = p.x; x < p.x + p.w; x += 64) {
                    this.platforms.create(x + 32, p.y + 20, 'ground');
                }
            } else {
                this.platforms.create(p.x, p.y, 'plat');
            }
        });
        
        // Hazards
        this.hazards = this.physics.add.staticGroup();
        L.haz.forEach(h => this.hazards.create(h.x, h.y, 'spikes'));
        
        // Portal
        this.portal = this.physics.add.staticImage(L.exit.x, L.exit.y, 'portal');
        this.tweens.add({ targets: this.portal, alpha: 0.5, scaleX: 1.1, duration: 800, yoyo: true, repeat: -1 });
        
        // Player
        this.player = this.physics.add.sprite(100, 500, 'player').setCollideWorldBounds(true);
        this.player.body.setSize(20, 50).setOffset(6, 4);
        
        // Enemies
        this.enemies = this.physics.add.group();
        L.enemies.forEach(e => {
            const enemy = this.enemies.create(e.x, e.y, e.t === 'd' ? 'drone' : 'guard');
            enemy.et = e.t;
            enemy.sx = e.x;
            enemy.dir = 1;
            enemy.hp = e.t === 'd' ? 30 : 60;
            enemy.dmg = e.t === 'd' ? 15 : 25;
            enemy.st = 0;
            if (e.t === 'd') enemy.body.allowGravity = false;
        });
        
        // Collectibles
        this.items = this.physics.add.group();
        L.items.forEach(item => {
            const it = this.items.create(item.x, item.y, item.t);
            it.body.allowGravity = false;
            it.itemType = item.t;
            this.tweens.add({ targets: it, y: item.y - 10, duration: 1500, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });
        });
        
        // Bullets
        this.bullets = this.physics.add.group();
        this.ebullets = this.physics.add.group();
        this.lastShot = 0;
        
        // Collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.enemies, this.platforms);
        this.physics.add.overlap(this.player, this.items, (p, i) => this.collectItem(i));
        this.physics.add.overlap(this.bullets, this.enemies, (b, e) => this.hitEnemy(b, e));
        this.physics.add.overlap(this.player, this.enemies, (p, e) => this.playerHit(e.dmg));
        this.physics.add.overlap(this.player, this.hazards, () => { this.playerHit(40); this.player.setVelocityY(-300); });
        this.physics.add.overlap(this.player, this.ebullets, (p, b) => { b.destroy(); this.playerHit(20); });
        this.physics.add.overlap(this.player, this.portal, () => this.win());
        
        // Input
        this.keys = this.input.keyboard.addKeys({ w: 'W', a: 'A', s: 'S', d: 'D', space: 'SPACE' });
        this.input.on('pointerdown', p => this.shoot(p));
        
        // Camera
        this.cameras.main.startFollow(this.player, true, 0.08, 0.08);
        
        // HUD
        this.createHUD();
        
        // Pause
        this.input.keyboard.on('keydown-ESC', () => {
            this.scene.pause();
            this.scene.launch('Pause', { lvl: this.lvl });
        });
        
        // Level intro
        this.showIntro(L.name);
    }
    
    getLevelData() {
        const levels = {
            1: { name: 'GENESIS BLOCK', w: 4000,
                plats: [
                    { x: 0, y: 680, w: 800, t: 'g' }, { x: 900, y: 680, w: 600, t: 'g' }, { x: 1600, y: 680, w: 800, t: 'g' }, { x: 2500, y: 680, w: 600, t: 'g' }, { x: 3200, y: 680, w: 800, t: 'g' },
                    { x: 300, y: 550, t: 'p' }, { x: 550, y: 450, t: 'p' }, { x: 200, y: 350, t: 'p' }, { x: 1000, y: 550, t: 'p' }, { x: 1250, y: 450, t: 'p' }, { x: 1500, y: 380, t: 'p' }, { x: 1800, y: 500, t: 'p' }, { x: 2100, y: 400, t: 'p' }, { x: 2400, y: 550, t: 'p' }, { x: 2700, y: 450, t: 'p' }, { x: 3000, y: 350, t: 'p' }, { x: 3300, y: 500, t: 'p' }, { x: 3600, y: 400, t: 'p' }
                ],
                enemies: [{ x: 600, y: 640, t: 'd' }, { x: 1100, y: 640, t: 'd' }, { x: 1700, y: 640, t: 'g' }, { x: 2200, y: 360, t: 'd' }, { x: 2800, y: 640, t: 'g' }, { x: 3400, y: 460, t: 'd' }],
                items: [{ x: 350, y: 510, t: 'crypto' }, { x: 600, y: 410, t: 'crypto' }, { x: 250, y: 310, t: 'key' }, { x: 1050, y: 510, t: 'crypto' }, { x: 1300, y: 410, t: 'crypto' }, { x: 1550, y: 340, t: 'key' }, { x: 1850, y: 460, t: 'health' }, { x: 2150, y: 360, t: 'crypto' }, { x: 2450, y: 510, t: 'key' }, { x: 2750, y: 410, t: 'crypto' }, { x: 3050, y: 310, t: 'energy' }, { x: 3350, y: 460, t: 'crypto' }, { x: 3650, y: 360, t: 'key' }],
                haz: [{ x: 850, y: 658 }, { x: 1550, y: 658 }, { x: 2450, y: 658 }, { x: 3150, y: 658 }],
                exit: { x: 3900, y: 620 }
            },
            2: { name: 'DATA BREACH', w: 5000,
                plats: [
                    { x: 0, y: 680, w: 600, t: 'g' }, { x: 700, y: 680, w: 400, t: 'g' }, { x: 1200, y: 680, w: 600, t: 'g' }, { x: 1900, y: 680, w: 400, t: 'g' }, { x: 2400, y: 680, w: 600, t: 'g' }, { x: 3100, y: 680, w: 400, t: 'g' }, { x: 3600, y: 680, w: 600, t: 'g' }, { x: 4300, y: 680, w: 700, t: 'g' },
                    { x: 400, y: 520, t: 'p' }, { x: 650, y: 420, t: 'p' }, { x: 350, y: 320, t: 'p' }, { x: 900, y: 520, t: 'p' }, { x: 1400, y: 480, t: 'p' }, { x: 1700, y: 380, t: 'p' }, { x: 2000, y: 500, t: 'p' }, { x: 2300, y: 400, t: 'p' }, { x: 2700, y: 520, t: 'p' }, { x: 3000, y: 420, t: 'p' }, { x: 3300, y: 320, t: 'p' }, { x: 3800, y: 480, t: 'p' }, { x: 4100, y: 380, t: 'p' }, { x: 4500, y: 500, t: 'p' }
                ],
                enemies: [{ x: 500, y: 640, t: 'd' }, { x: 900, y: 480, t: 'd' }, { x: 1500, y: 640, t: 'g' }, { x: 1800, y: 340, t: 'd' }, { x: 2500, y: 640, t: 'g' }, { x: 2900, y: 380, t: 'd' }, { x: 3400, y: 640, t: 'g' }, { x: 3900, y: 440, t: 'd' }, { x: 4400, y: 640, t: 'g' }],
                items: [{ x: 450, y: 480, t: 'crypto' }, { x: 700, y: 380, t: 'crypto' }, { x: 400, y: 280, t: 'key' }, { x: 950, y: 480, t: 'health' }, { x: 1450, y: 440, t: 'crypto' }, { x: 1750, y: 340, t: 'crypto' }, { x: 2050, y: 460, t: 'crypto' }, { x: 2350, y: 360, t: 'key' }, { x: 2750, y: 480, t: 'crypto' }, { x: 3050, y: 380, t: 'energy' }, { x: 3350, y: 280, t: 'crypto' }, { x: 3850, y: 440, t: 'health' }, { x: 4150, y: 340, t: 'key' }, { x: 4550, y: 460, t: 'crypto' }],
                haz: [{ x: 650, y: 658 }, { x: 1150, y: 658 }, { x: 1850, y: 658 }, { x: 2350, y: 658 }, { x: 3050, y: 658 }, { x: 3550, y: 658 }, { x: 4250, y: 658 }],
                exit: { x: 4850, y: 620 }
            },
            3: { name: 'ENCRYPTED RAILS', w: 5500,
                plats: [
                    { x: 0, y: 680, w: 500, t: 'g' }, { x: 600, y: 680, w: 300, t: 'g' }, { x: 1000, y: 680, w: 500, t: 'g' }, { x: 1600, y: 680, w: 300, t: 'g' }, { x: 2000, y: 680, w: 500, t: 'g' }, { x: 2600, y: 680, w: 300, t: 'g' }, { x: 3000, y: 680, w: 500, t: 'g' }, { x: 3600, y: 680, w: 300, t: 'g' }, { x: 4000, y: 680, w: 500, t: 'g' }, { x: 4600, y: 680, w: 900, t: 'g' },
                    { x: 250, y: 550, t: 'p' }, { x: 450, y: 450, t: 'p' }, { x: 250, y: 350, t: 'p' }, { x: 450, y: 250, t: 'p' }, { x: 750, y: 500, t: 'p' }, { x: 1200, y: 550, t: 'p' }, { x: 1450, y: 450, t: 'p' }, { x: 1750, y: 500, t: 'p' }, { x: 2200, y: 550, t: 'p' }, { x: 2450, y: 400, t: 'p' }, { x: 2750, y: 500, t: 'p' }, { x: 3200, y: 550, t: 'p' }, { x: 3450, y: 400, t: 'p' }, { x: 3750, y: 500, t: 'p' }, { x: 4200, y: 550, t: 'p' }, { x: 4450, y: 400, t: 'p' }, { x: 4800, y: 550, t: 'p' }, { x: 5100, y: 450, t: 'p' }
                ],
                enemies: [{ x: 400, y: 640, t: 'd' }, { x: 800, y: 460, t: 'd' }, { x: 1300, y: 640, t: 'g' }, { x: 1600, y: 460, t: 'd' }, { x: 2300, y: 640, t: 'g' }, { x: 2600, y: 460, t: 'd' }, { x: 3300, y: 640, t: 'g' }, { x: 3600, y: 460, t: 'd' }, { x: 4300, y: 640, t: 'g' }, { x: 4900, y: 510, t: 'd' }],
                items: [{ x: 300, y: 510, t: 'crypto' }, { x: 500, y: 410, t: 'crypto' }, { x: 300, y: 310, t: 'key' }, { x: 500, y: 210, t: 'energy' }, { x: 800, y: 460, t: 'crypto' }, { x: 1250, y: 510, t: 'health' }, { x: 1500, y: 410, t: 'crypto' }, { x: 1800, y: 460, t: 'crypto' }, { x: 2250, y: 510, t: 'crypto' }, { x: 2500, y: 360, t: 'key' }, { x: 2800, y: 460, t: 'crypto' }, { x: 3250, y: 510, t: 'health' }, { x: 3500, y: 360, t: 'crypto' }, { x: 3800, y: 460, t: 'crypto' }, { x: 4250, y: 510, t: 'crypto' }, { x: 4500, y: 360, t: 'key' }, { x: 4850, y: 510, t: 'energy' }, { x: 5150, y: 410, t: 'crypto' }],
                haz: [{ x: 550, y: 658 }, { x: 950, y: 658 }, { x: 1550, y: 658 }, { x: 1950, y: 658 }, { x: 2550, y: 658 }, { x: 2950, y: 658 }, { x: 3550, y: 658 }, { x: 3950, y: 658 }, { x: 4550, y: 658 }],
                exit: { x: 5350, y: 620 }
            },
            4: { name: 'FIREWALL', w: 4500,
                plats: [
                    { x: 0, y: 680, w: 1000, t: 'g' }, { x: 1100, y: 680, w: 800, t: 'g' }, { x: 2000, y: 680, w: 600, t: 'g' }, { x: 2700, y: 680, w: 800, t: 'g' }, { x: 3600, y: 680, w: 900, t: 'g' },
                    { x: 500, y: 550, t: 'p' }, { x: 300, y: 420, t: 'p' }, { x: 700, y: 420, t: 'p' }, { x: 500, y: 290, t: 'p' }, { x: 1300, y: 520, t: 'p' }, { x: 1600, y: 400, t: 'p' }, { x: 2200, y: 550, t: 'p' }, { x: 2450, y: 420, t: 'p' }, { x: 2900, y: 520, t: 'p' }, { x: 3150, y: 400, t: 'p' }, { x: 3400, y: 280, t: 'p' }, { x: 3900, y: 520, t: 'p' }, { x: 4150, y: 400, t: 'p' }
                ],
                enemies: [{ x: 400, y: 640, t: 'g' }, { x: 600, y: 510, t: 'd' }, { x: 350, y: 380, t: 'd' }, { x: 750, y: 380, t: 'd' }, { x: 1400, y: 640, t: 'g' }, { x: 1700, y: 360, t: 'd' }, { x: 2300, y: 640, t: 'g' }, { x: 2550, y: 380, t: 'd' }, { x: 3000, y: 640, t: 'g' }, { x: 3250, y: 360, t: 'd' }, { x: 4000, y: 640, t: 'g' }, { x: 4250, y: 360, t: 'd' }],
                items: [{ x: 550, y: 510, t: 'crypto' }, { x: 350, y: 380, t: 'health' }, { x: 750, y: 380, t: 'energy' }, { x: 550, y: 250, t: 'key' }, { x: 1350, y: 480, t: 'crypto' }, { x: 1650, y: 360, t: 'crypto' }, { x: 2250, y: 510, t: 'health' }, { x: 2500, y: 380, t: 'crypto' }, { x: 2950, y: 480, t: 'key' }, { x: 3200, y: 360, t: 'crypto' }, { x: 3450, y: 240, t: 'energy' }, { x: 3950, y: 480, t: 'health' }, { x: 4200, y: 360, t: 'key' }],
                haz: [{ x: 1050, y: 658 }, { x: 1950, y: 658 }, { x: 2650, y: 658 }, { x: 3550, y: 658 }],
                exit: { x: 4350, y: 620 }
            },
            5: { name: 'LIBERATION', w: 6000,
                plats: [
                    { x: 0, y: 680, w: 800, t: 'g' }, { x: 900, y: 680, w: 400, t: 'g' }, { x: 1400, y: 680, w: 600, t: 'g' }, { x: 2100, y: 680, w: 400, t: 'g' }, { x: 2600, y: 680, w: 600, t: 'g' }, { x: 3300, y: 680, w: 400, t: 'g' }, { x: 3800, y: 680, w: 600, t: 'g' }, { x: 4500, y: 680, w: 400, t: 'g' }, { x: 5000, y: 680, w: 1000, t: 'g' },
                    { x: 400, y: 550, t: 'p' }, { x: 650, y: 420, t: 'p' }, { x: 400, y: 290, t: 'p' }, { x: 1100, y: 500, t: 'p' }, { x: 1600, y: 550, t: 'p' }, { x: 1850, y: 420, t: 'p' }, { x: 2300, y: 500, t: 'p' }, { x: 2800, y: 550, t: 'p' }, { x: 3050, y: 420, t: 'p' }, { x: 3500, y: 500, t: 'p' }, { x: 4000, y: 550, t: 'p' }, { x: 4250, y: 420, t: 'p' }, { x: 4700, y: 500, t: 'p' }, { x: 5200, y: 550, t: 'p' }, { x: 5450, y: 420, t: 'p' }, { x: 5700, y: 290, t: 'p' }
                ],
                enemies: [{ x: 500, y: 640, t: 'g' }, { x: 700, y: 380, t: 'd' }, { x: 1200, y: 460, t: 'd' }, { x: 1700, y: 640, t: 'g' }, { x: 1950, y: 380, t: 'd' }, { x: 2400, y: 460, t: 'd' }, { x: 2900, y: 640, t: 'g' }, { x: 3150, y: 380, t: 'd' }, { x: 3600, y: 460, t: 'd' }, { x: 4100, y: 640, t: 'g' }, { x: 4350, y: 380, t: 'd' }, { x: 4800, y: 460, t: 'd' }, { x: 5300, y: 640, t: 'g' }, { x: 5550, y: 380, t: 'd' }],
                items: [{ x: 450, y: 510, t: 'crypto' }, { x: 700, y: 380, t: 'crypto' }, { x: 450, y: 250, t: 'key' }, { x: 1150, y: 460, t: 'health' }, { x: 1650, y: 510, t: 'crypto' }, { x: 1900, y: 380, t: 'crypto' }, { x: 2350, y: 460, t: 'crypto' }, { x: 2850, y: 510, t: 'energy' }, { x: 3100, y: 380, t: 'crypto' }, { x: 3550, y: 460, t: 'key' }, { x: 4050, y: 510, t: 'health' }, { x: 4300, y: 380, t: 'crypto' }, { x: 4750, y: 460, t: 'crypto' }, { x: 5250, y: 510, t: 'crypto' }, { x: 5500, y: 380, t: 'energy' }, { x: 5750, y: 250, t: 'key' }],
                haz: [{ x: 850, y: 658 }, { x: 1350, y: 658 }, { x: 2050, y: 658 }, { x: 2550, y: 658 }, { x: 3250, y: 658 }, { x: 3750, y: 658 }, { x: 4450, y: 658 }, { x: 4950, y: 658 }],
                exit: { x: 5900, y: 620 }
            }
        };
        return levels[this.lvl] || levels[1];
    }
    
    createHUD() {
        this.hpBar = this.add.graphics().setScrollFactor(0).setDepth(100);
        this.enBar = this.add.graphics().setScrollFactor(0).setDepth(100);
        
        this.add.rectangle(120, 27, 210, 24, 0x0a0a12, 0.8).setScrollFactor(0).setDepth(99);
        this.add.rectangle(120, 55, 210, 24, 0x0a0a12, 0.8).setScrollFactor(0).setDepth(99);
        
        this.add.text(20, 20, 'HP', { fontSize: '12px', color: '#ff4466' }).setScrollFactor(0).setDepth(100);
        this.add.text(20, 48, 'BOOST', { fontSize: '12px', color: '#D0A0B7' }).setScrollFactor(0).setDepth(100);
        
        this.scoreTxt = this.add.text(C.W - 20, 20, 'SCORE: 0', { fontSize: '20px', color: '#D0A0B7' }).setOrigin(1, 0).setScrollFactor(0).setDepth(100);
        this.cryptoTxt = this.add.text(C.W - 20, 45, 'CRYPTO: 0', { fontSize: '14px', color: '#8D6477' }).setOrigin(1, 0).setScrollFactor(0).setDepth(100);
        
        this.add.text(C.W / 2, 20, 'LEVEL ' + this.lvl, { fontSize: '14px', color: '#6A525D' }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(100);
        
        this.updateHUD();
    }
    
    updateHUD() {
        this.hpBar.clear();
        this.hpBar.fillStyle(C.red);
        this.hpBar.fillRect(55, 21, Math.max(0, 165 * (this.hp / 100)), 16);
        
        this.enBar.clear();
        this.enBar.fillStyle(C.pink);
        this.enBar.fillRect(55, 49, Math.max(0, 165 * (this.energy / 100)), 16);
        
        this.scoreTxt.setText('SCORE: ' + this.score);
        this.cryptoTxt.setText('CRYPTO: ' + this.crypto);
    }
    
    showIntro(name) {
        const ov = this.add.rectangle(C.W / 2, C.H / 2, C.W, C.H, 0x000000, 0.8).setScrollFactor(0).setDepth(200);
        const t1 = this.add.text(C.W / 2, C.H / 2 - 30, 'LEVEL ' + this.lvl, { fontSize: '48px', color: '#D0A0B7' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        const t2 = this.add.text(C.W / 2, C.H / 2 + 30, name, { fontSize: '24px', color: '#8D6477' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        
        this.time.delayedCall(1500, () => {
            this.tweens.add({
                targets: [ov, t1, t2],
                alpha: 0,
                duration: 500,
                onComplete: () => { ov.destroy(); t1.destroy(); t2.destroy(); }
            });
        });
    }
    
    update(time) {
        if (this.dead || this.won) return;
        
        const speed = 280;
        const boost = 420;
        const onGround = this.player.body.onFloor();
        
        // Movement
        if (this.keys.a.isDown) {
            this.player.setVelocityX(-speed);
            this.player.setFlipX(true);
        } else if (this.keys.d.isDown) {
            this.player.setVelocityX(speed);
            this.player.setFlipX(false);
        } else {
            this.player.setVelocityX(this.player.body.velocity.x * 0.85);
        }
        
        // Fly / Boost
        if (this.keys.space.isDown && this.energy > 0) {
            this.player.setVelocityY(-boost);
            this.energy -= 0.7;
            this.player.setTexture('player_fly');
        } else {
            this.player.setTexture('player');
            if (onGround) this.energy = Math.min(100, this.energy + 0.4);
        }
        
        // Enemies
        this.enemies.getChildren().forEach(e => {
            if (!e.active) return;
            const patrolDist = e.et === 'd' ? 180 : 120;
            e.x += e.dir * (e.et === 'd' ? 2 : 1.2);
            if (e.x > e.sx + patrolDist || e.x < e.sx - patrolDist) {
                e.dir *= -1;
                e.setFlipX(e.dir < 0);
            }
            
            // Guards shoot
            if (e.et === 'g' && Phaser.Math.Distance.Between(e.x, e.y, this.player.x, this.player.y) < 350 && time > e.st) {
                this.enemyShoot(e);
                e.st = time + 2000;
            }
        });
        
        // Cleanup bullets
        this.bullets.getChildren().forEach(b => { if (b.x < 0 || b.x > 6000) b.destroy(); });
        this.ebullets.getChildren().forEach(b => { if (b.x < 0 || b.x > 6000) b.destroy(); });
        
        this.updateHUD();
    }
    
    shoot(pointer) {
        if (this.time.now - this.lastShot < 180) return;
        this.lastShot = this.time.now;
        
        const bullet = this.bullets.create(this.player.x, this.player.y - 5, 'bullet');
        bullet.body.allowGravity = false;
        
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, worldPoint.x, worldPoint.y);
        bullet.setRotation(angle);
        this.physics.velocityFromRotation(angle, 650, bullet.body.velocity);
    }
    
    enemyShoot(enemy) {
        const bullet = this.ebullets.create(enemy.x, enemy.y, 'ebullet');
        bullet.body.allowGravity = false;
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
        this.physics.velocityFromRotation(angle, 300, bullet.body.velocity);
    }
    
    hitEnemy(bullet, enemy) {
        bullet.destroy();
        enemy.hp -= 25;
        if (enemy.hp <= 0) {
            enemy.destroy();
            this.score += enemy.et === 'd' ? 150 : 300;
        }
    }
    
    playerHit(damage) {
        if (this.player.inv || this.dead) return;
        
        this.hp -= damage;
        this.cameras.main.shake(100, 0.01);
        
        if (this.hp <= 0) {
            this.gameOver();
            return;
        }
        
        this.player.inv = true;
        this.tweens.add({
            targets: this.player,
            alpha: 0.4,
            duration: 80,
            yoyo: true,
            repeat: 6,
            onComplete: () => { this.player.inv = false; this.player.alpha = 1; }
        });
    }
    
    collectItem(item) {
        const type = item.itemType;
        item.destroy();
        
        switch (type) {
            case 'crypto': this.crypto++; this.score += 100; break;
            case 'key': this.score += 500; break;
            case 'health': this.hp = Math.min(100, this.hp + 35); break;
            case 'energy': this.energy = Math.min(100, this.energy + 50); break;
        }
    }
    
    async win() {
        if (this.won) return;
        this.won = true;
        this.physics.pause();
        
        this.cameras.main.flash(500, 208, 160, 183);
        
        // Save score
        if (currentUser) {
            await saveScore(currentUser.username, currentUser.realName, this.lvl, this.score, this.crypto);
        }
        
        showAchievement('Level Complete!', 'Score: ' + this.score);
        
        const w = C.W, h = C.H;
        this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.9).setScrollFactor(0).setDepth(200);
        this.add.text(w / 2, h / 2 - 100, 'LEVEL COMPLETE', { fontSize: '48px', color: '#D0A0B7' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        this.add.text(w / 2, h / 2 - 20, 'Score: ' + this.score, { fontSize: '24px', color: '#8D6477' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        this.add.text(w / 2, h / 2 + 20, 'Crypto: ' + this.crypto, { fontSize: '18px', color: '#D0A0B7' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        
        if (this.lvl < 5) {
            this.createButton(w / 2, h / 2 + 100, 'NEXT LEVEL', () => this.scene.restart({ level: this.lvl + 1 }));
        }
        this.createButton(w / 2, h / 2 + 165, 'MENU', () => this.scene.start('Levels'));
    }
    
    gameOver() {
        this.dead = true;
        this.physics.pause();
        this.cameras.main.shake(300, 0.02);
        
        const w = C.W, h = C.H;
        this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.9).setScrollFactor(0).setDepth(200);
        this.add.text(w / 2, h / 2 - 60, 'SYSTEM FAILURE', { fontSize: '48px', color: '#ff4466' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        this.add.text(w / 2, h / 2 + 10, 'Score: ' + this.score, { fontSize: '24px', color: '#D0A0B7' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        
        this.createButton(w / 2, h / 2 + 90, 'RETRY', () => this.scene.restart({ level: this.lvl }));
        this.createButton(w / 2, h / 2 + 155, 'MENU', () => this.scene.start('Levels'));
    }
    
    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'btn').setInteractive({ useHandCursor: true }).setScrollFactor(0).setDepth(200);
        const txt = this.add.text(x, y, text, { fontSize: '15px', color: '#D0A0B7' }).setOrigin(0.5).setScrollFactor(0).setDepth(200);
        btn.on('pointerover', () => { btn.setTexture('btn2'); txt.setColor('#0a0a12'); });
        btn.on('pointerout', () => { btn.setTexture('btn'); txt.setColor('#D0A0B7'); });
        btn.on('pointerdown', callback);
    }
}

// ============================================================
// PAUSE SCENE
// ============================================================
class Pause extends Phaser.Scene {
    constructor() { super('Pause'); }
    
    init(data) { this.lvl = data.lvl; }
    
    create() {
        const w = C.W, h = C.H;
        this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.85);
        this.add.text(w / 2, h / 2 - 100, 'PAUSED', { fontSize: '48px', color: '#D0A0B7' }).setOrigin(0.5);
        
        this.createButton(w / 2, h / 2, 'RESUME', () => { this.scene.stop(); this.scene.resume('Game'); });
        this.createButton(w / 2, h / 2 + 65, 'RESTART', () => { this.scene.stop(); this.scene.stop('Game'); this.scene.start('Game', { level: this.lvl }); });
        this.createButton(w / 2, h / 2 + 130, 'QUIT', () => { this.scene.stop(); this.scene.stop('Game'); this.scene.start('Levels'); });
    }
    
    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'btn').setInteractive({ useHandCursor: true });
        const txt = this.add.text(x, y, text, { fontSize: '15px', color: '#D0A0B7' }).setOrigin(0.5);
        btn.on('pointerover', () => { btn.setTexture('btn2'); txt.setColor('#0a0a12'); });
        btn.on('pointerout', () => { btn.setTexture('btn'); txt.setColor('#D0A0B7'); });
        btn.on('pointerdown', callback);
    }
}

// ============================================================
// START GAME
// ============================================================
window.game = new Phaser.Game({
    type: Phaser.AUTO,
    width: C.W,
    height: C.H,
    parent: 'game',
    backgroundColor: '#0a0a12',
    physics: {
        default: 'arcade',
        arcade: { gravity: { y: 900 }, debug: false }
    },
    scene: [Boot, Menu, Levels, Leaderboard, Game, Pause]
});
</script>
</body>
</html>
