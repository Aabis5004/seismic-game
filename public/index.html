<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEISMIC 2077 - Encrypt The Rails</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 2px solid #D0A0B7;
            box-shadow: 0 0 50px rgba(208, 160, 183, 0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>

<script>
// ============================================================
// SEISMIC 2077 - Professional Game with Phaser.js
// Theme: Encryption, Privacy, Blockchain Rails
// No emojis - Real graphics drawn with code
// ============================================================

const CONFIG = {
    width: 1280,
    height: 720,
    backgroundColor: '#0a0a12',
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 800 },
            debug: false
        }
    },
    scene: [BootScene, MenuScene, GameScene, UIScene]
};

// Color palette - Seismic brand
const COLORS = {
    primary: 0xD0A0B7,      // Seismic pink
    primaryDark: 0x6A525D,
    background: 0x0a0a12,
    ground: 0x1a1a2e,
    platform: 0x2d2d44,
    accent: 0x00ff88,       // Green for crypto/success
    danger: 0xff4466,       // Red for enemies
    blue: 0x4a9fff,
    text: 0xffffff,
    dark: 0x16213e
};

// ============================================================
// BOOT SCENE - Load assets, generate graphics
// ============================================================
class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }

    preload() {
        // Create loading bar
        const width = this.cameras.main.width;
        const height = this.cameras.main.height;
        
        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x1a1a2e, 0.8);
        progressBox.fillRect(width/2 - 160, height/2 - 15, 320, 30);
        
        const loadingText = this.add.text(width/2, height/2 - 50, 'SEISMIC 2077', {
            font: '32px Arial',
            fill: '#D0A0B7'
        }).setOrigin(0.5);
        
        const percentText = this.add.text(width/2, height/2, '0%', {
            font: '18px Arial',
            fill: '#ffffff'
        }).setOrigin(0.5);

        this.load.on('progress', (value) => {
            progressBar.clear();
            progressBar.fillStyle(0xD0A0B7, 1);
            progressBar.fillRect(width/2 - 155, height/2 - 10, 310 * value, 20);
            percentText.setText(parseInt(value * 100) + '%');
        });

        this.load.on('complete', () => {
            progressBar.destroy();
            progressBox.destroy();
            loadingText.destroy();
            percentText.destroy();
        });

        // Generate all graphics programmatically
        this.generateTextures();
    }

    generateTextures() {
        // Player character - cyberpunk operative
        this.generatePlayer();
        
        // Enemies
        this.generateEnemies();
        
        // Projectiles
        this.generateProjectiles();
        
        // Platforms
        this.generatePlatforms();
        
        // Collectibles
        this.generateCollectibles();
        
        // Particles
        this.generateParticles();
        
        // UI elements
        this.generateUI();
    }

    generatePlayer() {
        // Player idle
        const playerGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        // Body
        playerGraphics.fillStyle(0x1a1a2e, 1);
        playerGraphics.fillRoundedRect(8, 12, 16, 28, 4);
        
        // Armor plates
        playerGraphics.fillStyle(COLORS.primary, 1);
        playerGraphics.fillRoundedRect(10, 14, 12, 8, 2);
        playerGraphics.fillRoundedRect(10, 24, 12, 6, 2);
        
        // Head
        playerGraphics.fillStyle(0x2a2a3e, 1);
        playerGraphics.fillRoundedRect(10, 2, 12, 12, 3);
        
        // Visor
        playerGraphics.fillStyle(COLORS.accent, 1);
        playerGraphics.fillRect(12, 5, 8, 4);
        
        // Legs
        playerGraphics.fillStyle(0x1a1a2e, 1);
        playerGraphics.fillRect(10, 40, 5, 12);
        playerGraphics.fillRect(17, 40, 5, 12);
        
        // Boots
        playerGraphics.fillStyle(COLORS.primaryDark, 1);
        playerGraphics.fillRect(9, 48, 6, 4);
        playerGraphics.fillRect(16, 48, 6, 4);
        
        playerGraphics.generateTexture('player', 32, 54);
        playerGraphics.destroy();

        // Player running frames
        for (let i = 0; i < 4; i++) {
            const runGraphics = this.make.graphics({ x: 0, y: 0, add: false });
            const legOffset = Math.sin(i * Math.PI / 2) * 4;
            
            // Body
            runGraphics.fillStyle(0x1a1a2e, 1);
            runGraphics.fillRoundedRect(8, 12, 16, 28, 4);
            
            // Armor
            runGraphics.fillStyle(COLORS.primary, 1);
            runGraphics.fillRoundedRect(10, 14, 12, 8, 2);
            runGraphics.fillRoundedRect(10, 24, 12, 6, 2);
            
            // Head
            runGraphics.fillStyle(0x2a2a3e, 1);
            runGraphics.fillRoundedRect(10, 2, 12, 12, 3);
            
            // Visor
            runGraphics.fillStyle(COLORS.accent, 1);
            runGraphics.fillRect(12, 5, 8, 4);
            
            // Legs animated
            runGraphics.fillStyle(0x1a1a2e, 1);
            runGraphics.fillRect(10, 40 + legOffset, 5, 12);
            runGraphics.fillRect(17, 40 - legOffset, 5, 12);
            
            // Boots
            runGraphics.fillStyle(COLORS.primaryDark, 1);
            runGraphics.fillRect(9, 48 + legOffset, 6, 4);
            runGraphics.fillRect(16, 48 - legOffset, 6, 4);
            
            runGraphics.generateTexture('player_run_' + i, 32, 54);
            runGraphics.destroy();
        }

        // Player jump
        const jumpGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        jumpGraphics.fillStyle(0x1a1a2e, 1);
        jumpGraphics.fillRoundedRect(8, 12, 16, 28, 4);
        jumpGraphics.fillStyle(COLORS.primary, 1);
        jumpGraphics.fillRoundedRect(10, 14, 12, 8, 2);
        jumpGraphics.fillRoundedRect(10, 24, 12, 6, 2);
        jumpGraphics.fillStyle(0x2a2a3e, 1);
        jumpGraphics.fillRoundedRect(10, 2, 12, 12, 3);
        jumpGraphics.fillStyle(COLORS.accent, 1);
        jumpGraphics.fillRect(12, 5, 8, 4);
        // Legs tucked
        jumpGraphics.fillStyle(0x1a1a2e, 1);
        jumpGraphics.fillRect(10, 38, 5, 8);
        jumpGraphics.fillRect(17, 42, 5, 8);
        jumpGraphics.fillStyle(COLORS.primaryDark, 1);
        jumpGraphics.fillRect(9, 44, 6, 4);
        jumpGraphics.fillRect(16, 48, 6, 4);
        jumpGraphics.generateTexture('player_jump', 32, 54);
        jumpGraphics.destroy();
    }

    generateEnemies() {
        // Drone enemy
        const droneGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        // Body
        droneGraphics.fillStyle(0x2a1a1a, 1);
        droneGraphics.fillRoundedRect(4, 8, 24, 16, 4);
        
        // Eye
        droneGraphics.fillStyle(COLORS.danger, 1);
        droneGraphics.fillCircle(16, 16, 6);
        droneGraphics.fillStyle(0xffffff, 1);
        droneGraphics.fillCircle(18, 14, 2);
        
        // Wings
        droneGraphics.fillStyle(0x3a2a2a, 1);
        droneGraphics.fillRect(0, 4, 8, 4);
        droneGraphics.fillRect(24, 4, 8, 4);
        
        // Bottom light
        droneGraphics.fillStyle(COLORS.danger, 0.5);
        droneGraphics.fillRect(12, 24, 8, 4);
        
        droneGraphics.generateTexture('enemy_drone', 32, 32);
        droneGraphics.destroy();

        // Guard enemy
        const guardGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        // Body
        guardGraphics.fillStyle(0x2a1a1a, 1);
        guardGraphics.fillRoundedRect(6, 14, 20, 26, 4);
        
        // Armor
        guardGraphics.fillStyle(0x4a2a2a, 1);
        guardGraphics.fillRoundedRect(8, 16, 16, 10, 2);
        
        // Head
        guardGraphics.fillStyle(0x3a2a2a, 1);
        guardGraphics.fillRoundedRect(8, 2, 16, 14, 4);
        
        // Visor
        guardGraphics.fillStyle(COLORS.danger, 1);
        guardGraphics.fillRect(10, 6, 12, 4);
        
        // Legs
        guardGraphics.fillStyle(0x2a1a1a, 1);
        guardGraphics.fillRect(8, 40, 6, 12);
        guardGraphics.fillRect(18, 40, 6, 12);
        
        guardGraphics.generateTexture('enemy_guard', 32, 54);
        guardGraphics.destroy();

        // Boss enemy
        const bossGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        
        // Large body
        bossGraphics.fillStyle(0x1a0a0a, 1);
        bossGraphics.fillRoundedRect(8, 20, 48, 44, 8);
        
        // Armor plates
        bossGraphics.fillStyle(0x4a1a1a, 1);
        bossGraphics.fillRoundedRect(12, 24, 40, 16, 4);
        bossGraphics.fillRoundedRect(12, 44, 40, 12, 4);
        
        // Head
        bossGraphics.fillStyle(0x2a1a1a, 1);
        bossGraphics.fillRoundedRect(16, 4, 32, 20, 6);
        
        // Eyes
        bossGraphics.fillStyle(COLORS.danger, 1);
        bossGraphics.fillCircle(26, 12, 5);
        bossGraphics.fillCircle(38, 12, 5);
        
        // Core
        bossGraphics.fillStyle(COLORS.danger, 0.8);
        bossGraphics.fillCircle(32, 36, 8);
        
        bossGraphics.generateTexture('enemy_boss', 64, 72);
        bossGraphics.destroy();
    }

    generateProjectiles() {
        // Player bullet
        const bulletGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        bulletGraphics.fillStyle(COLORS.accent, 1);
        bulletGraphics.fillRoundedRect(0, 2, 16, 4, 2);
        bulletGraphics.fillStyle(0xffffff, 1);
        bulletGraphics.fillRect(12, 3, 4, 2);
        bulletGraphics.generateTexture('bullet', 16, 8);
        bulletGraphics.destroy();

        // Enemy bullet
        const enemyBulletGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        enemyBulletGraphics.fillStyle(COLORS.danger, 1);
        enemyBulletGraphics.fillCircle(6, 6, 6);
        enemyBulletGraphics.fillStyle(0xffffff, 0.5);
        enemyBulletGraphics.fillCircle(4, 4, 2);
        enemyBulletGraphics.generateTexture('enemy_bullet', 12, 12);
        enemyBulletGraphics.destroy();

        // Rocket
        const rocketGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        rocketGraphics.fillStyle(COLORS.primary, 1);
        rocketGraphics.fillRoundedRect(0, 2, 20, 6, 3);
        rocketGraphics.fillStyle(COLORS.danger, 1);
        rocketGraphics.fillTriangle(20, 5, 26, 5, 20, 2);
        rocketGraphics.fillTriangle(20, 5, 26, 5, 20, 8);
        rocketGraphics.generateTexture('rocket', 26, 10);
        rocketGraphics.destroy();
    }

    generatePlatforms() {
        // Ground tile
        const groundGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        groundGraphics.fillStyle(COLORS.ground, 1);
        groundGraphics.fillRect(0, 0, 64, 64);
        groundGraphics.fillStyle(0x252540, 1);
        groundGraphics.fillRect(0, 0, 64, 8);
        // Grid lines
        groundGraphics.lineStyle(1, 0x2a2a4a, 0.3);
        groundGraphics.strokeRect(0, 0, 32, 32);
        groundGraphics.strokeRect(32, 0, 32, 32);
        groundGraphics.strokeRect(0, 32, 32, 32);
        groundGraphics.strokeRect(32, 32, 32, 32);
        groundGraphics.generateTexture('ground', 64, 64);
        groundGraphics.destroy();

        // Platform
        const platformGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        platformGraphics.fillStyle(COLORS.platform, 1);
        platformGraphics.fillRoundedRect(0, 0, 128, 24, 4);
        platformGraphics.fillStyle(0x3d3d5c, 1);
        platformGraphics.fillRoundedRect(4, 4, 120, 16, 2);
        // Lights
        platformGraphics.fillStyle(COLORS.primary, 0.5);
        platformGraphics.fillCircle(20, 12, 3);
        platformGraphics.fillCircle(64, 12, 3);
        platformGraphics.fillCircle(108, 12, 3);
        platformGraphics.generateTexture('platform', 128, 24);
        platformGraphics.destroy();

        // Wall
        const wallGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        wallGraphics.fillStyle(0x1a1a2e, 1);
        wallGraphics.fillRect(0, 0, 32, 128);
        wallGraphics.fillStyle(0x252540, 1);
        for (let y = 0; y < 128; y += 32) {
            wallGraphics.fillRect(0, y, 32, 2);
        }
        wallGraphics.generateTexture('wall', 32, 128);
        wallGraphics.destroy();
    }

    generateCollectibles() {
        // Data crystal (crypto)
        const cryptoGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        // Outer glow
        cryptoGraphics.fillStyle(COLORS.accent, 0.2);
        cryptoGraphics.fillCircle(16, 16, 14);
        // Crystal shape
        cryptoGraphics.fillStyle(COLORS.accent, 1);
        cryptoGraphics.beginPath();
        cryptoGraphics.moveTo(16, 2);
        cryptoGraphics.lineTo(26, 10);
        cryptoGraphics.lineTo(26, 22);
        cryptoGraphics.lineTo(16, 30);
        cryptoGraphics.lineTo(6, 22);
        cryptoGraphics.lineTo(6, 10);
        cryptoGraphics.closePath();
        cryptoGraphics.fillPath();
        // Highlight
        cryptoGraphics.fillStyle(0xffffff, 0.5);
        cryptoGraphics.fillTriangle(16, 4, 24, 10, 16, 16);
        cryptoGraphics.generateTexture('crypto', 32, 32);
        cryptoGraphics.destroy();

        // Encryption key
        const keyGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        keyGraphics.fillStyle(COLORS.primary, 0.2);
        keyGraphics.fillCircle(16, 16, 14);
        // Key body
        keyGraphics.fillStyle(COLORS.primary, 1);
        keyGraphics.fillRoundedRect(6, 12, 16, 8, 2);
        // Key head
        keyGraphics.fillCircle(8, 16, 6);
        keyGraphics.fillStyle(COLORS.primaryDark, 1);
        keyGraphics.fillCircle(8, 16, 3);
        // Key teeth
        keyGraphics.fillStyle(COLORS.primary, 1);
        keyGraphics.fillRect(18, 14, 4, 6);
        keyGraphics.fillRect(24, 12, 4, 8);
        keyGraphics.generateTexture('key', 32, 32);
        keyGraphics.destroy();

        // Data packet
        const dataGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        dataGraphics.fillStyle(COLORS.blue, 0.2);
        dataGraphics.fillCircle(16, 16, 14);
        // Packet body
        dataGraphics.fillStyle(COLORS.blue, 1);
        dataGraphics.fillRoundedRect(6, 6, 20, 20, 4);
        // Binary lines
        dataGraphics.fillStyle(0xffffff, 0.7);
        dataGraphics.fillRect(9, 10, 14, 2);
        dataGraphics.fillRect(9, 15, 10, 2);
        dataGraphics.fillRect(9, 20, 14, 2);
        dataGraphics.generateTexture('data', 32, 32);
        dataGraphics.destroy();

        // Health pack
        const healthGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        healthGraphics.fillStyle(COLORS.danger, 0.2);
        healthGraphics.fillCircle(16, 16, 14);
        healthGraphics.fillStyle(0xffffff, 1);
        healthGraphics.fillRoundedRect(6, 6, 20, 20, 4);
        healthGraphics.fillStyle(COLORS.danger, 1);
        healthGraphics.fillRect(14, 9, 4, 14);
        healthGraphics.fillRect(9, 14, 14, 4);
        healthGraphics.generateTexture('health', 32, 32);
        healthGraphics.destroy();
    }

    generateParticles() {
        // Generic particle
        const particleGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        particleGraphics.fillStyle(0xffffff, 1);
        particleGraphics.fillCircle(4, 4, 4);
        particleGraphics.generateTexture('particle', 8, 8);
        particleGraphics.destroy();

        // Muzzle flash
        const flashGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        flashGraphics.fillStyle(COLORS.accent, 1);
        flashGraphics.fillCircle(8, 8, 8);
        flashGraphics.fillStyle(0xffffff, 1);
        flashGraphics.fillCircle(8, 8, 4);
        flashGraphics.generateTexture('muzzle_flash', 16, 16);
        flashGraphics.destroy();
    }

    generateUI() {
        // Button
        const btnGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        btnGraphics.fillStyle(COLORS.primaryDark, 1);
        btnGraphics.fillRoundedRect(0, 0, 200, 50, 8);
        btnGraphics.lineStyle(2, COLORS.primary, 1);
        btnGraphics.strokeRoundedRect(0, 0, 200, 50, 8);
        btnGraphics.generateTexture('button', 200, 50);
        btnGraphics.destroy();

        // Button hover
        const btnHoverGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        btnHoverGraphics.fillStyle(COLORS.primary, 1);
        btnHoverGraphics.fillRoundedRect(0, 0, 200, 50, 8);
        btnHoverGraphics.generateTexture('button_hover', 200, 50);
        btnHoverGraphics.destroy();

        // Health bar background
        const hpBgGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        hpBgGraphics.fillStyle(0x1a1a2e, 1);
        hpBgGraphics.fillRoundedRect(0, 0, 200, 20, 4);
        hpBgGraphics.lineStyle(2, 0x333, 1);
        hpBgGraphics.strokeRoundedRect(0, 0, 200, 20, 4);
        hpBgGraphics.generateTexture('hp_bar_bg', 200, 20);
        hpBgGraphics.destroy();

        // Health bar fill
        const hpFillGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        hpFillGraphics.fillStyle(COLORS.danger, 1);
        hpFillGraphics.fillRoundedRect(0, 0, 196, 16, 3);
        hpFillGraphics.generateTexture('hp_bar_fill', 196, 16);
        hpFillGraphics.destroy();

        // Energy bar fill
        const energyFillGraphics = this.make.graphics({ x: 0, y: 0, add: false });
        energyFillGraphics.fillStyle(COLORS.primary, 1);
        energyFillGraphics.fillRoundedRect(0, 0, 196, 16, 3);
        energyFillGraphics.generateTexture('energy_bar_fill', 196, 16);
        energyFillGraphics.destroy();
    }

    create() {
        this.scene.start('MenuScene');
    }
}

// ============================================================
// MENU SCENE
// ============================================================
class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
    }

    create() {
        const { width, height } = this.cameras.main;

        // Background
        this.createBackground();

        // Logo
        this.add.text(width/2, 150, 'SEISMIC', {
            fontSize: '72px',
            fontFamily: 'Arial Black',
            color: '#D0A0B7',
            stroke: '#6A525D',
            strokeThickness: 4
        }).setOrigin(0.5);

        this.add.text(width/2, 220, '2 0 7 7', {
            fontSize: '36px',
            fontFamily: 'Arial',
            color: '#00ff88'
        }).setOrigin(0.5);

        // Tagline
        this.add.text(width/2, 300, 'ENCRYPT THE RAILS', {
            fontSize: '18px',
            fontFamily: 'Arial',
            color: '#888',
            letterSpacing: 8
        }).setOrigin(0.5);

        // Description
        const desc = 'The year is 2077. Traditional banking is surveillance.\nSeismic builds encrypted blockchain rails for private finance.\nYou are an operative fighting to free the financial system.';
        this.add.text(width/2, 380, desc, {
            fontSize: '14px',
            fontFamily: 'Arial',
            color: '#666',
            align: 'center',
            lineSpacing: 8
        }).setOrigin(0.5);

        // Buttons
        this.createButton(width/2, 480, 'START MISSION', () => {
            this.scene.start('GameScene');
            this.scene.launch('UIScene');
        });

        this.createButton(width/2, 550, 'CONTROLS', () => {
            this.showControls();
        });

        // Controls hint
        this.add.text(width/2, height - 40, 'WASD - Move | SPACE - Jump | CLICK - Shoot | E - Interact', {
            fontSize: '12px',
            fontFamily: 'Arial',
            color: '#555'
        }).setOrigin(0.5);

        // Version
        this.add.text(20, height - 20, 'v1.0.0 | Built for Seismic Community', {
            fontSize: '10px',
            color: '#333'
        });
    }

    createBackground() {
        const { width, height } = this.cameras.main;
        
        // Gradient background
        const bg = this.add.graphics();
        bg.fillGradientStyle(0x1a1a2e, 0x1a1a2e, 0x0f0f23, 0x0f0f23, 1);
        bg.fillRect(0, 0, width, height);

        // Grid
        const grid = this.add.graphics();
        grid.lineStyle(1, COLORS.primary, 0.05);
        for (let x = 0; x < width; x += 50) {
            grid.lineBetween(x, 0, x, height);
        }
        for (let y = 0; y < height; y += 50) {
            grid.lineBetween(0, y, width, y);
        }

        // Floating particles
        for (let i = 0; i < 30; i++) {
            const x = Phaser.Math.Between(0, width);
            const y = Phaser.Math.Between(0, height);
            const size = Phaser.Math.Between(1, 3);
            const alpha = Phaser.Math.FloatBetween(0.1, 0.3);
            
            const particle = this.add.circle(x, y, size, COLORS.primary, alpha);
            
            this.tweens.add({
                targets: particle,
                y: y - 100,
                alpha: 0,
                duration: Phaser.Math.Between(3000, 6000),
                repeat: -1,
                onRepeat: () => {
                    particle.x = Phaser.Math.Between(0, width);
                    particle.y = height + 10;
                    particle.alpha = alpha;
                }
            });
        }
    }

    createButton(x, y, text, callback) {
        const btn = this.add.image(x, y, 'button').setInteractive();
        const btnText = this.add.text(x, y, text, {
            fontSize: '18px',
            fontFamily: 'Arial',
            color: '#D0A0B7'
        }).setOrigin(0.5);

        btn.on('pointerover', () => {
            btn.setTexture('button_hover');
            btnText.setColor('#0a0a12');
        });

        btn.on('pointerout', () => {
            btn.setTexture('button');
            btnText.setColor('#D0A0B7');
        });

        btn.on('pointerdown', callback);
    }

    showControls() {
        const { width, height } = this.cameras.main;
        
        const overlay = this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.8).setInteractive();
        
        const box = this.add.rectangle(width/2, height/2, 400, 350, 0x1a1a2e, 1);
        box.setStrokeStyle(2, COLORS.primary);

        const title = this.add.text(width/2, height/2 - 140, 'CONTROLS', {
            fontSize: '24px',
            color: '#D0A0B7'
        }).setOrigin(0.5);

        const controls = [
            'W / SPACE - Jump',
            'A / D - Move Left / Right',
            'MOUSE - Aim',
            'LEFT CLICK - Shoot',
            'E - Interact with NPCs',
            'ESC - Pause'
        ];

        controls.forEach((ctrl, i) => {
            this.add.text(width/2, height/2 - 80 + i * 35, ctrl, {
                fontSize: '16px',
                color: '#aaa'
            }).setOrigin(0.5);
        });

        const closeBtn = this.add.text(width/2, height/2 + 130, 'CLOSE', {
            fontSize: '18px',
            color: '#D0A0B7',
            backgroundColor: '#333',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();

        closeBtn.on('pointerdown', () => {
            overlay.destroy();
            box.destroy();
            title.destroy();
            closeBtn.destroy();
        });
    }
}

// ============================================================
// GAME SCENE - Main gameplay
// ============================================================
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
    }

    init() {
        this.score = 0;
        this.crypto = 0;
        this.playerHP = 100;
        this.playerEnergy = 100;
        this.gameOver = false;
        this.levelComplete = false;
    }

    create() {
        // World bounds
        this.physics.world.setBounds(0, 0, 4000, 720);
        this.cameras.main.setBounds(0, 0, 4000, 720);

        // Create world
        this.createBackground();
        this.createLevel();
        this.createPlayer();
        this.createEnemies();
        this.createCollectibles();
        this.createNPCs();

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys({
            up: Phaser.Input.Keyboard.KeyCodes.W,
            down: Phaser.Input.Keyboard.KeyCodes.S,
            left: Phaser.Input.Keyboard.KeyCodes.A,
            right: Phaser.Input.Keyboard.KeyCodes.D,
            interact: Phaser.Input.Keyboard.KeyCodes.E
        });

        // Shooting
        this.bullets = this.physics.add.group();
        this.lastShot = 0;
        this.input.on('pointerdown', (pointer) => this.shoot(pointer));

        // Collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.enemies, this.platforms);
        this.physics.add.overlap(this.player, this.collectibles, this.collectItem, null, this);
        this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.playerHit, null, this);

        // Camera follow
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

        // Pause
        this.input.keyboard.on('keydown-ESC', () => {
            this.scene.pause();
            this.scene.launch('PauseScene');
        });

        // Events
        this.events.on('resume', () => {
            // Resume game
        });
    }

    createBackground() {
        // Sky gradient
        const bg = this.add.graphics();
        bg.fillGradientStyle(0x2d1f3d, 0x2d1f3d, 0x0f3460, 0x0f3460, 1);
        bg.fillRect(0, 0, 4000, 720);
        bg.setScrollFactor(0);

        // Distant buildings (parallax)
        for (let i = 0; i < 20; i++) {
            const x = i * 250;
            const h = Phaser.Math.Between(200, 400);
            const w = Phaser.Math.Between(80, 150);
            
            const building = this.add.rectangle(x, 720 - h/2, w, h, 0x0a0a15);
            building.setScrollFactor(0.2);

            // Windows
            for (let wy = 720 - h + 30; wy < 700; wy += 40) {
                for (let wx = x - w/2 + 15; wx < x + w/2 - 15; wx += 25) {
                    const lit = Math.random() > 0.6;
                    const win = this.add.rectangle(wx, wy, 12, 20, lit ? COLORS.primary : 0x151525, lit ? 0.5 : 1);
                    win.setScrollFactor(0.2);
                }
            }
        }

        // Signs
        const signs = ['SEISMIC', 'ENCRYPT', 'PRIVATE', 'RAILS', 'BUILD'];
        signs.forEach((text, i) => {
            const sign = this.add.text(400 + i * 800, 250, text, {
                fontSize: '32px',
                color: '#D0A0B7'
            }).setAlpha(0.3).setScrollFactor(0.3);
        });

        // Grid overlay
        const grid = this.add.graphics();
        grid.lineStyle(1, COLORS.primary, 0.03);
        for (let x = 0; x < 4000; x += 100) {
            grid.lineBetween(x, 0, x, 720);
        }
        for (let y = 0; y < 720; y += 100) {
            grid.lineBetween(0, y, 4000, y);
        }
    }

    createLevel() {
        this.platforms = this.physics.add.staticGroup();

        // Ground
        for (let x = 0; x < 4000; x += 64) {
            const ground = this.platforms.create(x + 32, 700, 'ground');
            ground.setScale(1).refreshBody();
        }

        // Platforms
        const platformData = [
            { x: 300, y: 550 },
            { x: 550, y: 450 },
            { x: 200, y: 350 },
            { x: 800, y: 520 },
            { x: 1100, y: 450 },
            { x: 1400, y: 380 },
            { x: 1700, y: 500 },
            { x: 2000, y: 420 },
            { x: 2300, y: 350 },
            { x: 2600, y: 480 },
            { x: 2900, y: 400 },
            { x: 3200, y: 320 },
            { x: 3500, y: 450 },
            { x: 3750, y: 380 },
        ];

        platformData.forEach(p => {
            const platform = this.platforms.create(p.x, p.y, 'platform');
            platform.setScale(1).refreshBody();
        });

        // Exit portal
        this.exit = this.add.rectangle(3900, 600, 50, 80, COLORS.accent, 0.5);
        this.physics.add.existing(this.exit, true);
        
        // Exit glow animation
        this.tweens.add({
            targets: this.exit,
            alpha: 0.2,
            duration: 1000,
            yoyo: true,
            repeat: -1
        });

        this.physics.add.overlap(this.player, this.exit, () => {
            if (!this.levelComplete) {
                this.levelComplete = true;
                this.showLevelComplete();
            }
        }, null, this);
    }

    createPlayer() {
        this.player = this.physics.add.sprite(100, 500, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.body.setSize(20, 50);
        this.player.body.setOffset(6, 4);

        // Animation frames
        this.anims.create({
            key: 'run',
            frames: [
                { key: 'player_run_0' },
                { key: 'player_run_1' },
                { key: 'player_run_2' },
                { key: 'player_run_3' }
            ],
            frameRate: 10,
            repeat: -1
        });

        this.anims.create({
            key: 'idle',
            frames: [{ key: 'player' }],
            frameRate: 1
        });

        this.anims.create({
            key: 'jump',
            frames: [{ key: 'player_jump' }],
            frameRate: 1
        });
    }

    createEnemies() {
        this.enemies = this.physics.add.group();

        const enemyData = [
            { x: 600, y: 600, type: 'drone', patrol: 200 },
            { x: 1000, y: 400, type: 'drone', patrol: 150 },
            { x: 1500, y: 600, type: 'guard', patrol: 100 },
            { x: 2000, y: 370, type: 'drone', patrol: 180 },
            { x: 2500, y: 600, type: 'guard', patrol: 150 },
            { x: 3000, y: 350, type: 'drone', patrol: 200 },
            { x: 3400, y: 600, type: 'guard', patrol: 120 },
        ];

        enemyData.forEach(data => {
            const enemy = this.enemies.create(data.x, data.y, 'enemy_' + data.type);
            enemy.setCollideWorldBounds(true);
            enemy.body.setAllowGravity(data.type !== 'drone');
            enemy.hp = data.type === 'drone' ? 30 : 50;
            enemy.damage = data.type === 'drone' ? 10 : 20;
            enemy.patrol = data.patrol;
            enemy.startX = data.x;
            enemy.direction = 1;
            enemy.type = data.type;
        });
    }

    createCollectibles() {
        this.collectibles = this.physics.add.group();

        const items = [
            { x: 350, y: 500, type: 'crypto' },
            { x: 580, y: 400, type: 'crypto' },
            { x: 250, y: 300, type: 'key' },
            { x: 850, y: 470, type: 'crypto' },
            { x: 1150, y: 400, type: 'data' },
            { x: 1450, y: 330, type: 'crypto' },
            { x: 1750, y: 450, type: 'health' },
            { x: 2050, y: 370, type: 'crypto' },
            { x: 2350, y: 300, type: 'key' },
            { x: 2650, y: 430, type: 'crypto' },
            { x: 2950, y: 350, type: 'data' },
            { x: 3250, y: 270, type: 'crypto' },
            { x: 3550, y: 400, type: 'key' },
        ];

        items.forEach(item => {
            const collectible = this.collectibles.create(item.x, item.y, item.type);
            collectible.body.setAllowGravity(false);
            collectible.itemType = item.type;
            
            // Float animation
            this.tweens.add({
                targets: collectible,
                y: item.y - 10,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        });
    }

    createNPCs() {
        // NPCs for interaction
        this.npcs = [];

        const npcData = [
            { x: 150, y: 650, name: 'LYRONS', dialog: [
                'Welcome to the Seismic Underground.',
                'Traditional banking tracks every transaction.',
                'We build encrypted rails for private finance.',
                'Collect encryption keys to strengthen our network.',
                'The future of financial privacy depends on you.'
            ]},
            { x: 1200, y: 650, name: 'CIPHER', dialog: [
                'You made it past the first sector.',
                'The drones report to the Central Bank.',
                'Destroy them to protect our operations.',
                'Keep moving - the exit is ahead.'
            ]},
            { x: 2400, y: 650, name: 'NOVA', dialog: [
                'Almost there, operative.',
                'These encrypted rails will revolutionize finance.',
                'No more surveillance. No more trapped capital.',
                'Seismic is the future.'
            ]}
        ];

        npcData.forEach(data => {
            const npc = this.add.rectangle(data.x, data.y, 30, 50, COLORS.blue);
            npc.name = data.name;
            npc.dialog = data.dialog;
            npc.dialogIndex = 0;
            this.npcs.push(npc);

            // Name label
            this.add.text(data.x, data.y - 45, data.name, {
                fontSize: '12px',
                color: '#00aaff'
            }).setOrigin(0.5);
        });
    }

    update(time, delta) {
        if (this.gameOver || this.levelComplete) return;

        this.updatePlayer();
        this.updateEnemies();
        this.updateBullets();
        this.checkNPCInteraction();
        this.updateUI();
    }

    updatePlayer() {
        const speed = 300;
        const jump = -450;

        // Movement
        if (this.cursors.left.isDown || this.wasd.left.isDown) {
            this.player.setVelocityX(-speed);
            this.player.setFlipX(true);
            if (this.player.body.onFloor()) this.player.anims.play('run', true);
        } else if (this.cursors.right.isDown || this.wasd.right.isDown) {
            this.player.setVelocityX(speed);
            this.player.setFlipX(false);
            if (this.player.body.onFloor()) this.player.anims.play('run', true);
        } else {
            this.player.setVelocityX(0);
            if (this.player.body.onFloor()) this.player.anims.play('idle', true);
        }

        // Jump
        if ((this.cursors.up.isDown || this.wasd.up.isDown || this.cursors.space.isDown) && this.player.body.onFloor()) {
            this.player.setVelocityY(jump);
        }

        // Jump animation
        if (!this.player.body.onFloor()) {
            this.player.anims.play('jump', true);
        }

        // Energy regen
        this.playerEnergy = Math.min(100, this.playerEnergy + 0.05);
    }

    updateEnemies() {
        this.enemies.getChildren().forEach(enemy => {
            if (enemy.active) {
                // Patrol
                enemy.x += enemy.direction * 1.5;
                if (enemy.x > enemy.startX + enemy.patrol || enemy.x < enemy.startX - enemy.patrol) {
                    enemy.direction *= -1;
                    enemy.setFlipX(enemy.direction < 0);
                }
            }
        });
    }

    updateBullets() {
        this.bullets.getChildren().forEach(bullet => {
            if (bullet.x < 0 || bullet.x > 4000 || bullet.y < 0 || bullet.y > 720) {
                bullet.destroy();
            }
        });
    }

    shoot(pointer) {
        const now = this.time.now;
        if (now - this.lastShot < 200) return; // Fire rate limit
        if (this.playerEnergy < 5) return;

        this.lastShot = now;
        this.playerEnergy -= 5;

        const bullet = this.bullets.create(this.player.x, this.player.y, 'bullet');
        bullet.body.setAllowGravity(false);

        // Aim direction
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, worldPoint.x, worldPoint.y);
        
        bullet.setRotation(angle);
        this.physics.velocityFromRotation(angle, 600, bullet.body.velocity);

        // Muzzle flash
        const flash = this.add.image(this.player.x + Math.cos(angle) * 20, this.player.y + Math.sin(angle) * 20, 'muzzle_flash');
        this.time.delayedCall(50, () => flash.destroy());
    }

    hitEnemy(bullet, enemy) {
        bullet.destroy();
        enemy.hp -= 25;

        // Hit effect
        this.tweens.add({
            targets: enemy,
            tint: 0xffffff,
            duration: 50,
            yoyo: true
        });

        if (enemy.hp <= 0) {
            // Explosion particles
            for (let i = 0; i < 10; i++) {
                const particle = this.add.circle(
                    enemy.x + Phaser.Math.Between(-20, 20),
                    enemy.y + Phaser.Math.Between(-20, 20),
                    Phaser.Math.Between(3, 8),
                    COLORS.danger
                );
                this.tweens.add({
                    targets: particle,
                    alpha: 0,
                    scale: 0,
                    duration: 300,
                    onComplete: () => particle.destroy()
                });
            }

            enemy.destroy();
            this.score += 200;
            this.events.emit('scoreUpdate', this.score);
        }
    }

    playerHit(player, enemy) {
        if (player.invulnerable) return;

        this.playerHP -= enemy.damage;
        this.events.emit('hpUpdate', this.playerHP);

        // Knockback
        const dir = player.x < enemy.x ? -1 : 1;
        player.setVelocity(dir * 200, -200);

        // Invulnerability
        player.invulnerable = true;
        this.tweens.add({
            targets: player,
            alpha: 0.5,
            duration: 100,
            yoyo: true,
            repeat: 5,
            onComplete: () => {
                player.invulnerable = false;
                player.alpha = 1;
            }
        });

        if (this.playerHP <= 0) {
            this.showGameOver();
        }
    }

    collectItem(player, item) {
        const type = item.itemType;
        item.destroy();

        let message = '';
        let color = COLORS.accent;

        switch (type) {
            case 'crypto':
                this.crypto++;
                this.score += 100;
                message = '+100 CRYPTO';
                break;
            case 'key':
                this.score += 500;
                message = '+500 ENCRYPTION KEY';
                color = COLORS.primary;
                this.showInfo('ENCRYPTION KEY', 'Encryption keys secure transactions on Seismic blockchain.\nPrivate rails mean your financial data stays hidden.');
                break;
            case 'data':
                this.score += 300;
                message = '+300 DATA PACKET';
                color = COLORS.blue;
                this.showInfo('DATA PACKET', 'Data packets contain encrypted transaction info.\nSeismic processes millions of these privately.');
                break;
            case 'health':
                this.playerHP = Math.min(100, this.playerHP + 30);
                message = '+30 HP';
                color = COLORS.danger;
                break;
        }

        this.events.emit('scoreUpdate', this.score);
        this.events.emit('cryptoUpdate', this.crypto);
        this.events.emit('hpUpdate', this.playerHP);

        // Floating text
        const text = this.add.text(player.x, player.y - 30, message, {
            fontSize: '16px',
            color: Phaser.Display.Color.IntegerToColor(color).rgba
        }).setOrigin(0.5);

        this.tweens.add({
            targets: text,
            y: text.y - 50,
            alpha: 0,
            duration: 1000,
            onComplete: () => text.destroy()
        });
    }

    checkNPCInteraction() {
        this.npcs.forEach(npc => {
            const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, npc.x, npc.y);
            
            if (dist < 60) {
                // Show interaction prompt
                if (!npc.prompt) {
                    npc.prompt = this.add.text(npc.x, npc.y - 70, '[E] Talk', {
                        fontSize: '12px',
                        color: '#00ff88'
                    }).setOrigin(0.5);
                }

                if (Phaser.Input.Keyboard.JustDown(this.wasd.interact)) {
                    this.showDialog(npc);
                }
            } else if (npc.prompt) {
                npc.prompt.destroy();
                npc.prompt = null;
            }
        });
    }

    showDialog(npc) {
        this.scene.pause();
        this.scene.launch('DialogScene', { 
            name: npc.name, 
            dialog: npc.dialog,
            parentScene: this
        });
    }

    showInfo(title, text) {
        this.scene.pause();
        this.scene.launch('InfoScene', { title, text, parentScene: this });
    }

    showGameOver() {
        this.gameOver = true;
        this.scene.pause();
        this.scene.launch('GameOverScene', { score: this.score, parentScene: this });
    }

    showLevelComplete() {
        this.scene.pause();
        this.scene.launch('LevelCompleteScene', { 
            score: this.score, 
            crypto: this.crypto,
            parentScene: this 
        });
    }

    updateUI() {
        this.events.emit('energyUpdate', this.playerEnergy);
    }
}

// ============================================================
// UI SCENE - HUD overlay
// ============================================================
class UIScene extends Phaser.Scene {
    constructor() {
        super({ key: 'UIScene' });
    }

    create() {
        // Health bar
        this.add.image(120, 30, 'hp_bar_bg');
        this.hpFill = this.add.image(22, 30, 'hp_bar_fill').setOrigin(0, 0.5);
        this.add.text(20, 30, 'HP', { fontSize: '12px', color: '#ff4466' }).setOrigin(0, 0.5);

        // Energy bar
        this.add.image(120, 55, 'hp_bar_bg');
        this.energyFill = this.add.image(22, 55, 'energy_bar_fill').setOrigin(0, 0.5);
        this.add.text(20, 55, 'EN', { fontSize: '12px', color: '#D0A0B7' }).setOrigin(0, 0.5);

        // Score
        this.scoreText = this.add.text(1260, 20, 'Score: 0', {
            fontSize: '24px',
            color: '#D0A0B7'
        }).setOrigin(1, 0);

        // Crypto
        this.cryptoText = this.add.text(1260, 50, 'Crypto: 0', {
            fontSize: '18px',
            color: '#00ff88'
        }).setOrigin(1, 0);

        // Level
        this.add.text(640, 20, 'LEVEL 1: GENESIS BLOCK', {
            fontSize: '14px',
            color: '#666'
        }).setOrigin(0.5, 0);

        // Events from game scene
        const gameScene = this.scene.get('GameScene');
        
        gameScene.events.on('scoreUpdate', (score) => {
            this.scoreText.setText('Score: ' + score);
        });

        gameScene.events.on('cryptoUpdate', (crypto) => {
            this.cryptoText.setText('Crypto: ' + crypto);
        });

        gameScene.events.on('hpUpdate', (hp) => {
            this.hpFill.setScale(Math.max(0, hp) / 100, 1);
        });

        gameScene.events.on('energyUpdate', (energy) => {
            this.energyFill.setScale(Math.max(0, energy) / 100, 1);
        });
    }
}

// ============================================================
// DIALOG SCENE
// ============================================================
class DialogScene extends Phaser.Scene {
    constructor() {
        super({ key: 'DialogScene' });
    }

    init(data) {
        this.npcName = data.name;
        this.dialogLines = data.dialog;
        this.parentScene = data.parentScene;
        this.currentLine = 0;
    }

    create() {
        const { width, height } = this.cameras.main;

        // Dim background
        this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.5);

        // Dialog box
        const box = this.add.rectangle(width/2, height - 100, 800, 150, 0x1a1a2e, 0.95);
        box.setStrokeStyle(2, COLORS.primary);

        // Name
        this.add.text(width/2 - 380, height - 160, this.npcName, {
            fontSize: '18px',
            color: '#00aaff'
        });

        // Text
        this.dialogText = this.add.text(width/2, height - 100, this.dialogLines[0], {
            fontSize: '16px',
            color: '#ffffff',
            wordWrap: { width: 750 }
        }).setOrigin(0.5);

        // Continue hint
        this.add.text(width/2, height - 35, 'Press SPACE to continue', {
            fontSize: '12px',
            color: '#666'
        }).setOrigin(0.5);

        // Input
        this.input.keyboard.on('keydown-SPACE', () => this.nextLine());
        this.input.on('pointerdown', () => this.nextLine());
    }

    nextLine() {
        this.currentLine++;
        if (this.currentLine >= this.dialogLines.length) {
            this.scene.stop();
            this.scene.resume('GameScene');
        } else {
            this.dialogText.setText(this.dialogLines[this.currentLine]);
        }
    }
}

// ============================================================
// INFO SCENE
// ============================================================
class InfoScene extends Phaser.Scene {
    constructor() {
        super({ key: 'InfoScene' });
    }

    init(data) {
        this.title = data.title;
        this.infoText = data.text;
        this.parentScene = data.parentScene;
    }

    create() {
        const { width, height } = this.cameras.main;

        this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.8);

        const box = this.add.rectangle(width/2, height/2, 500, 250, 0x1a1a2e, 0.98);
        box.setStrokeStyle(2, COLORS.accent);

        this.add.text(width/2, height/2 - 80, this.title, {
            fontSize: '24px',
            color: '#00ff88'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2, this.infoText, {
            fontSize: '14px',
            color: '#aaa',
            align: 'center',
            wordWrap: { width: 450 }
        }).setOrigin(0.5);

        const closeBtn = this.add.text(width/2, height/2 + 90, 'GOT IT', {
            fontSize: '18px',
            color: '#0a0a12',
            backgroundColor: '#00ff88',
            padding: { x: 30, y: 10 }
        }).setOrigin(0.5).setInteractive();

        closeBtn.on('pointerdown', () => {
            this.scene.stop();
            this.scene.resume('GameScene');
        });
    }
}

// ============================================================
// GAME OVER SCENE
// ============================================================
class GameOverScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameOverScene' });
    }

    init(data) {
        this.finalScore = data.score;
    }

    create() {
        const { width, height } = this.cameras.main;

        this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.9);

        this.add.text(width/2, height/2 - 80, 'SYSTEM FAILURE', {
            fontSize: '48px',
            color: '#ff4466'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2, 'Final Score: ' + this.finalScore, {
            fontSize: '24px',
            color: '#D0A0B7'
        }).setOrigin(0.5);

        const retryBtn = this.add.text(width/2, height/2 + 60, 'TRY AGAIN', {
            fontSize: '18px',
            color: '#D0A0B7',
            backgroundColor: '#333',
            padding: { x: 30, y: 10 }
        }).setOrigin(0.5).setInteractive();

        retryBtn.on('pointerdown', () => {
            this.scene.stop('UIScene');
            this.scene.stop('GameScene');
            this.scene.stop();
            this.scene.start('GameScene');
            this.scene.launch('UIScene');
        });

        const menuBtn = this.add.text(width/2, height/2 + 120, 'MENU', {
            fontSize: '18px',
            color: '#888',
            backgroundColor: '#222',
            padding: { x: 30, y: 10 }
        }).setOrigin(0.5).setInteractive();

        menuBtn.on('pointerdown', () => {
            this.scene.stop('UIScene');
            this.scene.stop('GameScene');
            this.scene.stop();
            this.scene.start('MenuScene');
        });
    }
}

// ============================================================
// LEVEL COMPLETE SCENE
// ============================================================
class LevelCompleteScene extends Phaser.Scene {
    constructor() {
        super({ key: 'LevelCompleteScene' });
    }

    init(data) {
        this.finalScore = data.score;
        this.crypto = data.crypto;
    }

    create() {
        const { width, height } = this.cameras.main;

        this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.9);

        this.add.text(width/2, height/2 - 100, 'LEVEL COMPLETE', {
            fontSize: '48px',
            color: '#00ff88'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2 - 20, `Crypto Collected: ${this.crypto}\nScore: ${this.finalScore}`, {
            fontSize: '20px',
            color: '#aaa',
            align: 'center'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2 + 40, 'Seismic rails are now stronger.\nPrivacy for everyone.', {
            fontSize: '14px',
            color: '#666',
            align: 'center'
        }).setOrigin(0.5);

        const nextBtn = this.add.text(width/2, height/2 + 120, 'CONTINUE', {
            fontSize: '18px',
            color: '#0a0a12',
            backgroundColor: '#00ff88',
            padding: { x: 30, y: 10 }
        }).setOrigin(0.5).setInteractive();

        nextBtn.on('pointerdown', () => {
            this.scene.stop('UIScene');
            this.scene.stop('GameScene');
            this.scene.stop();
            this.scene.start('MenuScene');
        });
    }
}

// ============================================================
// START GAME
// ============================================================
const game = new Phaser.Game(CONFIG);
</script>
</body>
</html>
